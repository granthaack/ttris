
ttris.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000100  00800100  000008a4  00000958  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000008a4  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000001f8  00800200  00800200  00000a58  2**0
                  ALLOC
  3 .eeprom       00000004  00810000  00810000  00000a58  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  4 .comment      00000030  00000000  00000000  00000a5c  2**0
                  CONTENTS, READONLY
  5 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000a8c  2**2
                  CONTENTS, READONLY
  6 .debug_aranges 00000150  00000000  00000000  00000ad0  2**3
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00001b56  00000000  00000000  00000c20  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00000b59  00000000  00000000  00002776  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00000de8  00000000  00000000  000032cf  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  000001ec  00000000  00000000  000040b8  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00000505  00000000  00000000  000042a4  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    0000121c  00000000  00000000  000047a9  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000280  00000000  00000000  000059c5  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 3b 00 	jmp	0x76	; 0x76 <__ctors_end>
   4:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
   8:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
   c:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
  10:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
  14:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
  18:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
  1c:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
  20:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
  24:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
  28:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
  2c:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
  30:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
  34:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
  38:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
  3c:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
  40:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
  44:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
  48:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
  4c:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
  50:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
  54:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
  58:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
  5c:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
  60:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
  64:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
  68:	c9 01       	movw	r24, r18
  6a:	d4 01       	movw	r26, r8
  6c:	df 01       	movw	r26, r30
  6e:	ea 01       	movw	r28, r20
  70:	f5 01       	movw	r30, r10
  72:	be 01       	movw	r22, r28
  74:	b4 01       	movw	r22, r8

00000076 <__ctors_end>:
  76:	11 24       	eor	r1, r1
  78:	1f be       	out	0x3f, r1	; 63
  7a:	cf ef       	ldi	r28, 0xFF	; 255
  7c:	d8 e0       	ldi	r29, 0x08	; 8
  7e:	de bf       	out	0x3e, r29	; 62
  80:	cd bf       	out	0x3d, r28	; 61

00000082 <__do_copy_data>:
  82:	12 e0       	ldi	r17, 0x02	; 2
  84:	a0 e0       	ldi	r26, 0x00	; 0
  86:	b1 e0       	ldi	r27, 0x01	; 1
  88:	e4 ea       	ldi	r30, 0xA4	; 164
  8a:	f8 e0       	ldi	r31, 0x08	; 8
  8c:	02 c0       	rjmp	.+4      	; 0x92 <__do_copy_data+0x10>
  8e:	05 90       	lpm	r0, Z+
  90:	0d 92       	st	X+, r0
  92:	a0 30       	cpi	r26, 0x00	; 0
  94:	b1 07       	cpc	r27, r17
  96:	d9 f7       	brne	.-10     	; 0x8e <__do_copy_data+0xc>

00000098 <__do_clear_bss>:
  98:	23 e0       	ldi	r18, 0x03	; 3
  9a:	a0 e0       	ldi	r26, 0x00	; 0
  9c:	b2 e0       	ldi	r27, 0x02	; 2
  9e:	01 c0       	rjmp	.+2      	; 0xa2 <.do_clear_bss_start>

000000a0 <.do_clear_bss_loop>:
  a0:	1d 92       	st	X+, r1

000000a2 <.do_clear_bss_start>:
  a2:	a8 3f       	cpi	r26, 0xF8	; 248
  a4:	b2 07       	cpc	r27, r18
  a6:	e1 f7       	brne	.-8      	; 0xa0 <.do_clear_bss_loop>
  a8:	0e 94 44 03 	call	0x688	; 0x688 <main>
  ac:	0c 94 50 04 	jmp	0x8a0	; 0x8a0 <_exit>

000000b0 <__bad_interrupt>:
  b0:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000b4 <check_collision>:
#include "game.h"

void check_collision(struct sprite* spr)
{
  b4:	ff 92       	push	r15
  b6:	0f 93       	push	r16
  b8:	1f 93       	push	r17
  ba:	cf 93       	push	r28
  bc:	df 93       	push	r29
  be:	ec 01       	movw	r28, r24
	//Clear all the collisions since they will be recalculated
	spr->coll ^= spr->coll;
  c0:	18 86       	std	Y+8, r1	; 0x08
	
	//SCREEN COLLISIONS
	//If sprite has collided with the left of the screen
	if(spr->x_pos <= 0)
  c2:	9a 81       	ldd	r25, Y+2	; 0x02
  c4:	91 11       	cpse	r25, r1
  c6:	14 c1       	rjmp	.+552    	; 0x2f0 <check_collision+0x23c>
	{
		//Set the 4th collision bit
		spr->coll |= 0b00001000;
  c8:	88 e0       	ldi	r24, 0x08	; 8
  ca:	88 87       	std	Y+8, r24	; 0x08
  cc:	2a e0       	ldi	r18, 0x0A	; 10
	}

	//If sprite has collided with the top of the screen
	if(spr->y_pos <= 0)
  ce:	4b 81       	ldd	r20, Y+3	; 0x03
  d0:	41 11       	cpse	r20, r1
  d2:	02 c0       	rjmp	.+4      	; 0xd8 <check_collision+0x24>
	{
		//Set the 2nd collision bit
		spr->coll |= 0b00000010;
  d4:	28 87       	std	Y+8, r18	; 0x08
  d6:	82 2f       	mov	r24, r18
	}
	
	//If sprite has collided with the right of the screen
	if(((spr->x_pos)+spr->wdth) >= 83)
  d8:	5e 81       	ldd	r21, Y+6	; 0x06
  da:	25 2f       	mov	r18, r21
  dc:	30 e0       	ldi	r19, 0x00	; 0
  de:	29 0f       	add	r18, r25
  e0:	31 1d       	adc	r19, r1
  e2:	23 35       	cpi	r18, 0x53	; 83
  e4:	31 05       	cpc	r19, r1
  e6:	14 f0       	brlt	.+4      	; 0xec <check_collision+0x38>
	{
		//Set the 3rd collision bit
		spr->coll |= 0b00000100;
  e8:	84 60       	ori	r24, 0x04	; 4
  ea:	88 87       	std	Y+8, r24	; 0x08
	}

	//If sprite has collided with the bottom of the screen
	if(((spr->y_pos)+spr->hght) >= 47)
  ec:	9f 81       	ldd	r25, Y+7	; 0x07
  ee:	29 2f       	mov	r18, r25
  f0:	30 e0       	ldi	r19, 0x00	; 0
  f2:	24 0f       	add	r18, r20
  f4:	31 1d       	adc	r19, r1
  f6:	2f 32       	cpi	r18, 0x2F	; 47
  f8:	31 05       	cpc	r19, r1
  fa:	14 f0       	brlt	.+4      	; 0x100 <check_collision+0x4c>
	{
		//Set the 1st collision bit
		spr->coll |= 0b00000001;
  fc:	81 60       	ori	r24, 0x01	; 1
  fe:	88 87       	std	Y+8, r24	; 0x08
	}
	
	//PIECE COLLISIONS
	//Check if sprite has left collided with another piece if it hasn't already collided with a wall
	if(!(spr->coll & 0b00001000))
 100:	83 fd       	sbrc	r24, 3
 102:	3a c0       	rjmp	.+116    	; 0x178 <check_collision+0xc4>
	{
			//Scan the sprite column by column
			bool spr_px = 0;
			bool fbf_px = 0;
			for(uint8_t x = 0; x < spr->wdth; x++)
 104:	55 23       	and	r21, r21
 106:	c1 f1       	breq	.+112    	; 0x178 <check_collision+0xc4>
 108:	00 e0       	ldi	r16, 0x00	; 0
			{
				for(uint8_t y = 0;  y < spr->hght; y++)
 10a:	99 23       	and	r25, r25
 10c:	79 f1       	breq	.+94     	; 0x16c <check_collision+0xb8>
 10e:	10 e0       	ldi	r17, 0x00	; 0
 110:	05 c0       	rjmp	.+10     	; 0x11c <check_collision+0x68>
 112:	1f 5f       	subi	r17, 0xFF	; 255
 114:	8f 81       	ldd	r24, Y+7	; 0x07
 116:	18 17       	cp	r17, r24
 118:	08 f0       	brcs	.+2      	; 0x11c <check_collision+0x68>
 11a:	ed c0       	rjmp	.+474    	; 0x2f6 <check_collision+0x242>
				{
					//Get the current sprite pixel from the spritemap
					spr_px = read_pixel((spr->x_map+x), (spr->y_map+y), spritemap);
 11c:	69 81       	ldd	r22, Y+1	; 0x01
 11e:	61 0f       	add	r22, r17
 120:	88 81       	ld	r24, Y
 122:	44 e0       	ldi	r20, 0x04	; 4
 124:	51 e0       	ldi	r21, 0x01	; 1
 126:	80 0f       	add	r24, r16
 128:	0e 94 30 02 	call	0x460	; 0x460 <read_pixel>
 12c:	f8 2e       	mov	r15, r24
					//Get the current fbuff pixel directly to the left of the current sprite pixel in the fbuff
					fbf_px = read_pixel((spr->x_pos + x - 1), (spr->y_pos + y), fbuff);
 12e:	6b 81       	ldd	r22, Y+3	; 0x03
 130:	61 0f       	add	r22, r17
 132:	8a 81       	ldd	r24, Y+2	; 0x02
 134:	81 50       	subi	r24, 0x01	; 1
 136:	40 e0       	ldi	r20, 0x00	; 0
 138:	52 e0       	ldi	r21, 0x02	; 2
 13a:	80 0f       	add	r24, r16
 13c:	0e 94 30 02 	call	0x460	; 0x460 <read_pixel>
					//If the pixel to the left of an active sprite pixel in the fbuff is 1 AND it's not a sprite pixel, there is a collision
					if(fbf_px && spr_px && (!(read_pixel((spr->x_map + x - 1), (spr->y_map+y), spritemap))))
 140:	88 23       	and	r24, r24
 142:	39 f3       	breq	.-50     	; 0x112 <check_collision+0x5e>
 144:	ff 20       	and	r15, r15
 146:	29 f3       	breq	.-54     	; 0x112 <check_collision+0x5e>
 148:	69 81       	ldd	r22, Y+1	; 0x01
 14a:	61 0f       	add	r22, r17
 14c:	88 81       	ld	r24, Y
 14e:	81 50       	subi	r24, 0x01	; 1
 150:	44 e0       	ldi	r20, 0x04	; 4
 152:	51 e0       	ldi	r21, 0x01	; 1
 154:	80 0f       	add	r24, r16
 156:	0e 94 30 02 	call	0x460	; 0x460 <read_pixel>
 15a:	81 11       	cpse	r24, r1
 15c:	da cf       	rjmp	.-76     	; 0x112 <check_collision+0x5e>
					{
						//Set the 4th collision bit and break the loop
						spr->coll |= 0b00001000;
 15e:	88 85       	ldd	r24, Y+8	; 0x08
 160:	88 60       	ori	r24, 0x08	; 8
 162:	88 87       	std	Y+8, r24	; 0x08
 164:	98 2f       	mov	r25, r24
 166:	98 70       	andi	r25, 0x08	; 8
						break;
					}
				}
				//If a left collision has been detected, don't look for any more left collisions
				if(spr->coll & 0b00001000)
 168:	91 11       	cpse	r25, r1
 16a:	06 c0       	rjmp	.+12     	; 0x178 <check_collision+0xc4>
	if(!(spr->coll & 0b00001000))
	{
			//Scan the sprite column by column
			bool spr_px = 0;
			bool fbf_px = 0;
			for(uint8_t x = 0; x < spr->wdth; x++)
 16c:	0f 5f       	subi	r16, 0xFF	; 255
 16e:	9e 81       	ldd	r25, Y+6	; 0x06
 170:	09 17       	cp	r16, r25
 172:	10 f4       	brcc	.+4      	; 0x178 <check_collision+0xc4>
 174:	9f 81       	ldd	r25, Y+7	; 0x07
 176:	c9 cf       	rjmp	.-110    	; 0x10a <check_collision+0x56>
				}
			}
	}

	//Check if sprite has right collided with another piece if it hasn't already collided with a wall
	if(!(spr->coll & 0b00000100))
 178:	82 fd       	sbrc	r24, 2
 17a:	3a c0       	rjmp	.+116    	; 0x1f0 <check_collision+0x13c>
	{
			//Scan the sprite column by column
			bool spr_px = 0;
			bool fbf_px = 0;
			for(uint8_t x = 0; x < spr->wdth; x++)
 17c:	9e 81       	ldd	r25, Y+6	; 0x06
 17e:	99 23       	and	r25, r25
 180:	b9 f1       	breq	.+110    	; 0x1f0 <check_collision+0x13c>
 182:	00 e0       	ldi	r16, 0x00	; 0
			{
				for(uint8_t y = 0;  y < spr->hght; y++)
 184:	9f 81       	ldd	r25, Y+7	; 0x07
 186:	99 23       	and	r25, r25
 188:	79 f1       	breq	.+94     	; 0x1e8 <check_collision+0x134>
 18a:	10 e0       	ldi	r17, 0x00	; 0
 18c:	05 c0       	rjmp	.+10     	; 0x198 <check_collision+0xe4>
 18e:	1f 5f       	subi	r17, 0xFF	; 255
 190:	8f 81       	ldd	r24, Y+7	; 0x07
 192:	18 17       	cp	r17, r24
 194:	08 f0       	brcs	.+2      	; 0x198 <check_collision+0xe4>
 196:	b3 c0       	rjmp	.+358    	; 0x2fe <check_collision+0x24a>
				{
					//Get the current sprite pixel from the spritemap
					spr_px = read_pixel((spr->x_map+x), (spr->y_map+y), spritemap);
 198:	69 81       	ldd	r22, Y+1	; 0x01
 19a:	61 0f       	add	r22, r17
 19c:	88 81       	ld	r24, Y
 19e:	44 e0       	ldi	r20, 0x04	; 4
 1a0:	51 e0       	ldi	r21, 0x01	; 1
 1a2:	80 0f       	add	r24, r16
 1a4:	0e 94 30 02 	call	0x460	; 0x460 <read_pixel>
 1a8:	f8 2e       	mov	r15, r24
					//Get the current fbuff pixel directly to the right of the current sprite pixel in the fbuff
					fbf_px = read_pixel((spr->x_pos + x + 1), (spr->y_pos + y), fbuff);
 1aa:	6b 81       	ldd	r22, Y+3	; 0x03
 1ac:	61 0f       	add	r22, r17
 1ae:	8a 81       	ldd	r24, Y+2	; 0x02
 1b0:	8f 5f       	subi	r24, 0xFF	; 255
 1b2:	40 e0       	ldi	r20, 0x00	; 0
 1b4:	52 e0       	ldi	r21, 0x02	; 2
 1b6:	80 0f       	add	r24, r16
 1b8:	0e 94 30 02 	call	0x460	; 0x460 <read_pixel>
					//If the pixel to the right of an active sprite pixel in the fbuff is 1 AND it's not a sprite pixel, there is a collision
					if(fbf_px && spr_px && (!(read_pixel((spr->x_map + x + 1), (spr->y_map+y), spritemap))))
 1bc:	88 23       	and	r24, r24
 1be:	39 f3       	breq	.-50     	; 0x18e <check_collision+0xda>
 1c0:	ff 20       	and	r15, r15
 1c2:	29 f3       	breq	.-54     	; 0x18e <check_collision+0xda>
 1c4:	69 81       	ldd	r22, Y+1	; 0x01
 1c6:	61 0f       	add	r22, r17
 1c8:	88 81       	ld	r24, Y
 1ca:	8f 5f       	subi	r24, 0xFF	; 255
 1cc:	44 e0       	ldi	r20, 0x04	; 4
 1ce:	51 e0       	ldi	r21, 0x01	; 1
 1d0:	80 0f       	add	r24, r16
 1d2:	0e 94 30 02 	call	0x460	; 0x460 <read_pixel>
 1d6:	81 11       	cpse	r24, r1
 1d8:	da cf       	rjmp	.-76     	; 0x18e <check_collision+0xda>
					{
						//Set the 3rd collision bit and break the loop
						spr->coll |= 0b00000100;
 1da:	88 85       	ldd	r24, Y+8	; 0x08
 1dc:	84 60       	ori	r24, 0x04	; 4
 1de:	88 87       	std	Y+8, r24	; 0x08
 1e0:	98 2f       	mov	r25, r24
 1e2:	94 70       	andi	r25, 0x04	; 4
						break;
					}
				}
				//If a right collision has been detected, don't look for any more right collisions
				if(spr->coll & 0b00000100)
 1e4:	91 11       	cpse	r25, r1
 1e6:	04 c0       	rjmp	.+8      	; 0x1f0 <check_collision+0x13c>
	if(!(spr->coll & 0b00000100))
	{
			//Scan the sprite column by column
			bool spr_px = 0;
			bool fbf_px = 0;
			for(uint8_t x = 0; x < spr->wdth; x++)
 1e8:	0f 5f       	subi	r16, 0xFF	; 255
 1ea:	9e 81       	ldd	r25, Y+6	; 0x06
 1ec:	09 17       	cp	r16, r25
 1ee:	50 f2       	brcs	.-108    	; 0x184 <check_collision+0xd0>
				}
			}
	}

	//Check if sprite has top collided with another piece if it hasn't already collided with a wall
	if(!(spr->coll & 0b00000010))
 1f0:	81 fd       	sbrc	r24, 1
 1f2:	3b c0       	rjmp	.+118    	; 0x26a <check_collision+0x1b6>
	{
		//Scan the sprite column by column
		bool spr_px = 0;
		bool fbf_px = 0;
		for(uint8_t x = 0; x < spr->wdth; x++)
 1f4:	9e 81       	ldd	r25, Y+6	; 0x06
 1f6:	99 23       	and	r25, r25
 1f8:	09 f4       	brne	.+2      	; 0x1fc <check_collision+0x148>
 1fa:	71 c0       	rjmp	.+226    	; 0x2de <check_collision+0x22a>
 1fc:	00 e0       	ldi	r16, 0x00	; 0
		{
			for(uint8_t y = 0;  y < spr->hght; y++)
 1fe:	9f 81       	ldd	r25, Y+7	; 0x07
 200:	99 23       	and	r25, r25
 202:	79 f1       	breq	.+94     	; 0x262 <check_collision+0x1ae>
 204:	10 e0       	ldi	r17, 0x00	; 0
 206:	05 c0       	rjmp	.+10     	; 0x212 <check_collision+0x15e>
 208:	1f 5f       	subi	r17, 0xFF	; 255
 20a:	8f 81       	ldd	r24, Y+7	; 0x07
 20c:	18 17       	cp	r17, r24
 20e:	08 f0       	brcs	.+2      	; 0x212 <check_collision+0x15e>
 210:	7a c0       	rjmp	.+244    	; 0x306 <check_collision+0x252>
			{
				//Get the current sprite pixel from the spritemap
				spr_px = read_pixel((spr->x_map+x), (spr->y_map+y), spritemap);
 212:	69 81       	ldd	r22, Y+1	; 0x01
 214:	61 0f       	add	r22, r17
 216:	88 81       	ld	r24, Y
 218:	44 e0       	ldi	r20, 0x04	; 4
 21a:	51 e0       	ldi	r21, 0x01	; 1
 21c:	80 0f       	add	r24, r16
 21e:	0e 94 30 02 	call	0x460	; 0x460 <read_pixel>
 222:	f8 2e       	mov	r15, r24
				//Get the current fbuff pixel directly above of the current sprite pixel in the fbuff
				fbf_px = read_pixel((spr->x_pos + x), (spr->y_pos + y - 1), fbuff);
 224:	6b 81       	ldd	r22, Y+3	; 0x03
 226:	61 50       	subi	r22, 0x01	; 1
 228:	61 0f       	add	r22, r17
 22a:	8a 81       	ldd	r24, Y+2	; 0x02
 22c:	40 e0       	ldi	r20, 0x00	; 0
 22e:	52 e0       	ldi	r21, 0x02	; 2
 230:	80 0f       	add	r24, r16
 232:	0e 94 30 02 	call	0x460	; 0x460 <read_pixel>
				//If the pixel above an active sprite pixel in the fbuff is 1 AND it's not a sprite pixel, there is a collision
				if(fbf_px && spr_px && (!(read_pixel((spr->x_map + x), (spr->y_map+y-1), spritemap))))
 236:	88 23       	and	r24, r24
 238:	39 f3       	breq	.-50     	; 0x208 <check_collision+0x154>
 23a:	ff 20       	and	r15, r15
 23c:	29 f3       	breq	.-54     	; 0x208 <check_collision+0x154>
 23e:	69 81       	ldd	r22, Y+1	; 0x01
 240:	61 50       	subi	r22, 0x01	; 1
 242:	61 0f       	add	r22, r17
 244:	88 81       	ld	r24, Y
 246:	44 e0       	ldi	r20, 0x04	; 4
 248:	51 e0       	ldi	r21, 0x01	; 1
 24a:	80 0f       	add	r24, r16
 24c:	0e 94 30 02 	call	0x460	; 0x460 <read_pixel>
 250:	81 11       	cpse	r24, r1
 252:	da cf       	rjmp	.-76     	; 0x208 <check_collision+0x154>
				{
					//Set the 2nd collision bit and break the loop
					spr->coll |= 0b00000010;
 254:	88 85       	ldd	r24, Y+8	; 0x08
 256:	82 60       	ori	r24, 0x02	; 2
 258:	88 87       	std	Y+8, r24	; 0x08
 25a:	98 2f       	mov	r25, r24
 25c:	92 70       	andi	r25, 0x02	; 2
					break;
				}
			}
			//If a top collision has been detected, don't look for any more top collisions
			if(spr->coll & 0b00000010)
 25e:	91 11       	cpse	r25, r1
 260:	04 c0       	rjmp	.+8      	; 0x26a <check_collision+0x1b6>
	if(!(spr->coll & 0b00000010))
	{
		//Scan the sprite column by column
		bool spr_px = 0;
		bool fbf_px = 0;
		for(uint8_t x = 0; x < spr->wdth; x++)
 262:	0f 5f       	subi	r16, 0xFF	; 255
 264:	9e 81       	ldd	r25, Y+6	; 0x06
 266:	09 17       	cp	r16, r25
 268:	50 f2       	brcs	.-108    	; 0x1fe <check_collision+0x14a>
			}
		}
	}

	//Check if sprite has bottom collided with another piece if it hasn't already collided with a wall
	if(!(spr->coll & 0b00000001))
 26a:	80 fd       	sbrc	r24, 0
 26c:	38 c0       	rjmp	.+112    	; 0x2de <check_collision+0x22a>
	{
		//Scan the sprite column by column
		bool spr_px = 0;
		bool fbf_px = 0;
		for(uint8_t x = 0; x < spr->wdth; x++)
 26e:	8e 81       	ldd	r24, Y+6	; 0x06
 270:	88 23       	and	r24, r24
 272:	a9 f1       	breq	.+106    	; 0x2de <check_collision+0x22a>
 274:	00 e0       	ldi	r16, 0x00	; 0
		{
			for(uint8_t y = 0;  y < spr->hght; y++)
 276:	8f 81       	ldd	r24, Y+7	; 0x07
 278:	88 23       	and	r24, r24
 27a:	69 f1       	breq	.+90     	; 0x2d6 <check_collision+0x222>
 27c:	10 e0       	ldi	r17, 0x00	; 0
 27e:	04 c0       	rjmp	.+8      	; 0x288 <check_collision+0x1d4>
 280:	1f 5f       	subi	r17, 0xFF	; 255
 282:	8f 81       	ldd	r24, Y+7	; 0x07
 284:	18 17       	cp	r17, r24
 286:	88 f5       	brcc	.+98     	; 0x2ea <check_collision+0x236>
			{
				//Get the current sprite pixel from the spritemap
				spr_px = read_pixel((spr->x_map+x), (spr->y_map+y), spritemap);
 288:	69 81       	ldd	r22, Y+1	; 0x01
 28a:	61 0f       	add	r22, r17
 28c:	88 81       	ld	r24, Y
 28e:	44 e0       	ldi	r20, 0x04	; 4
 290:	51 e0       	ldi	r21, 0x01	; 1
 292:	80 0f       	add	r24, r16
 294:	0e 94 30 02 	call	0x460	; 0x460 <read_pixel>
 298:	f8 2e       	mov	r15, r24
				//Get the current fbuff pixel directly below the current sprite pixel in the fbuff
				fbf_px = read_pixel((spr->x_pos + x), (spr->y_pos + y + 1), fbuff);
 29a:	6b 81       	ldd	r22, Y+3	; 0x03
 29c:	6f 5f       	subi	r22, 0xFF	; 255
 29e:	61 0f       	add	r22, r17
 2a0:	8a 81       	ldd	r24, Y+2	; 0x02
 2a2:	40 e0       	ldi	r20, 0x00	; 0
 2a4:	52 e0       	ldi	r21, 0x02	; 2
 2a6:	80 0f       	add	r24, r16
 2a8:	0e 94 30 02 	call	0x460	; 0x460 <read_pixel>
				//If the pixel below an active sprite pixel in the fbuff is 1 AND it's not a sprite pixel, there is a collision
				if(fbf_px && spr_px && (!(read_pixel((spr->x_map + x), (spr->y_map+y+1), spritemap))))
 2ac:	88 23       	and	r24, r24
 2ae:	41 f3       	breq	.-48     	; 0x280 <check_collision+0x1cc>
 2b0:	ff 20       	and	r15, r15
 2b2:	31 f3       	breq	.-52     	; 0x280 <check_collision+0x1cc>
 2b4:	69 81       	ldd	r22, Y+1	; 0x01
 2b6:	6f 5f       	subi	r22, 0xFF	; 255
 2b8:	61 0f       	add	r22, r17
 2ba:	88 81       	ld	r24, Y
 2bc:	44 e0       	ldi	r20, 0x04	; 4
 2be:	51 e0       	ldi	r21, 0x01	; 1
 2c0:	80 0f       	add	r24, r16
 2c2:	0e 94 30 02 	call	0x460	; 0x460 <read_pixel>
 2c6:	81 11       	cpse	r24, r1
 2c8:	db cf       	rjmp	.-74     	; 0x280 <check_collision+0x1cc>
				{
					//Set the 1st collision bit and break the loop
					spr->coll |= 0b00000001;
 2ca:	88 85       	ldd	r24, Y+8	; 0x08
 2cc:	81 60       	ori	r24, 0x01	; 1
 2ce:	88 87       	std	Y+8, r24	; 0x08
 2d0:	81 70       	andi	r24, 0x01	; 1
					break;
				}
			}
			//If a left collision has been detected, don't look for any more left collisions
			if(spr->coll & 0b00000001)
 2d2:	81 11       	cpse	r24, r1
 2d4:	04 c0       	rjmp	.+8      	; 0x2de <check_collision+0x22a>
	if(!(spr->coll & 0b00000001))
	{
		//Scan the sprite column by column
		bool spr_px = 0;
		bool fbf_px = 0;
		for(uint8_t x = 0; x < spr->wdth; x++)
 2d6:	0f 5f       	subi	r16, 0xFF	; 255
 2d8:	8e 81       	ldd	r24, Y+6	; 0x06
 2da:	08 17       	cp	r16, r24
 2dc:	60 f2       	brcs	.-104    	; 0x276 <check_collision+0x1c2>
			{
				break;
			}
		}
	}
}
 2de:	df 91       	pop	r29
 2e0:	cf 91       	pop	r28
 2e2:	1f 91       	pop	r17
 2e4:	0f 91       	pop	r16
 2e6:	ff 90       	pop	r15
 2e8:	08 95       	ret
 2ea:	88 85       	ldd	r24, Y+8	; 0x08
 2ec:	81 70       	andi	r24, 0x01	; 1
 2ee:	f1 cf       	rjmp	.-30     	; 0x2d2 <check_collision+0x21e>
 2f0:	22 e0       	ldi	r18, 0x02	; 2
 2f2:	80 e0       	ldi	r24, 0x00	; 0
 2f4:	ec ce       	rjmp	.-552    	; 0xce <check_collision+0x1a>
 2f6:	88 85       	ldd	r24, Y+8	; 0x08
 2f8:	98 2f       	mov	r25, r24
 2fa:	98 70       	andi	r25, 0x08	; 8
 2fc:	35 cf       	rjmp	.-406    	; 0x168 <check_collision+0xb4>
 2fe:	88 85       	ldd	r24, Y+8	; 0x08
 300:	98 2f       	mov	r25, r24
 302:	94 70       	andi	r25, 0x04	; 4
 304:	6f cf       	rjmp	.-290    	; 0x1e4 <check_collision+0x130>
 306:	88 85       	ldd	r24, Y+8	; 0x08
 308:	98 2f       	mov	r25, r24
 30a:	92 70       	andi	r25, 0x02	; 2
 30c:	a8 cf       	rjmp	.-176    	; 0x25e <check_collision+0x1aa>

0000030e <init_rand>:
	//If eeprom is unwritten, initialize it with something
	if (state == 0xffffffUL)
	{
		state = 0xdebc0decUL;
	}
	srand(state);
 30e:	8c ee       	ldi	r24, 0xEC	; 236
 310:	9d e0       	ldi	r25, 0x0D	; 13
 312:	0e 94 c7 03 	call	0x78e	; 0x78e <srand>
	eeprom_write_dword(&sstate, rand());
 316:	0e 94 c2 03 	call	0x784	; 0x784 <rand>
 31a:	ac 01       	movw	r20, r24
 31c:	99 0f       	add	r25, r25
 31e:	66 0b       	sbc	r22, r22
 320:	77 0b       	sbc	r23, r23
 322:	80 e0       	ldi	r24, 0x00	; 0
 324:	90 e0       	ldi	r25, 0x00	; 0
 326:	0c 94 d2 03 	jmp	0x7a4	; 0x7a4 <eeprom_write_dword>

0000032a <soft_drop>:
}

void soft_drop(struct sprite* spr)
{
	spr->x_pos -= 2;
 32a:	fc 01       	movw	r30, r24
 32c:	22 81       	ldd	r18, Z+2	; 0x02
 32e:	22 50       	subi	r18, 0x02	; 2
 330:	22 83       	std	Z+2, r18	; 0x02
	draw_sprite(spr);
 332:	0c 94 cc 02 	jmp	0x598	; 0x598 <draw_sprite>

00000336 <spawn_new_tmino>:
	return;
}

void spawn_new_tmino(struct sprite* spr)
{
 336:	cf 93       	push	r28
 338:	df 93       	push	r29
 33a:	ec 01       	movw	r28, r24
	//Reset the coordinates without allowing the draw_frame function to erase the old piece
	spr->x_pos = X_ORIGIN;
 33c:	9c e3       	ldi	r25, 0x3C	; 60
 33e:	9a 83       	std	Y+2, r25	; 0x02
	spr->y_pos = Y_ORIGIN;
 340:	84 e1       	ldi	r24, 0x14	; 20
 342:	8b 83       	std	Y+3, r24	; 0x03
	spr->x_ppos = X_ORIGIN;
 344:	9c 83       	std	Y+4, r25	; 0x04
	spr->y_ppos = Y_ORIGIN;
 346:	8d 83       	std	Y+5, r24	; 0x05
	//Clear the collision data
	spr->coll ^= spr->coll;
 348:	18 86       	std	Y+8, r1	; 0x08
	//Get a random number between 0 and 6 with bitmasking and casting
	uint8_t r_piece = 0;
	r_piece = rand();
 34a:	0e 94 c2 03 	call	0x784	; 0x784 <rand>
	r_piece = r_piece & 0x0F;
 34e:	8f 70       	andi	r24, 0x0F	; 15
	if(r_piece > 6)
 350:	87 30       	cpi	r24, 0x07	; 7
 352:	08 f0       	brcs	.+2      	; 0x356 <spawn_new_tmino+0x20>
	{
		r_piece -= 9;
 354:	89 50       	subi	r24, 0x09	; 9
	}
	//Use it to choose a new piece to drop
	switch(r_piece)
 356:	90 e0       	ldi	r25, 0x00	; 0
 358:	87 30       	cpi	r24, 0x07	; 7
 35a:	91 05       	cpc	r25, r1
 35c:	60 f4       	brcc	.+24     	; 0x376 <spawn_new_tmino+0x40>
 35e:	fc 01       	movw	r30, r24
 360:	ec 5c       	subi	r30, 0xCC	; 204
 362:	ff 4f       	sbci	r31, 0xFF	; 255
 364:	0c 94 70 03 	jmp	0x6e0	; 0x6e0 <__tablejump2__>
			break;
		};
		//Drop an O piece
		case(6):
		{
			spr->hght = O_U_H;
 368:	84 e0       	ldi	r24, 0x04	; 4
 36a:	8f 83       	std	Y+7, r24	; 0x07
			spr->wdth = O_U_W;
 36c:	8e 83       	std	Y+6, r24	; 0x06
			spr->x_map = O_U_X;
 36e:	8c e4       	ldi	r24, 0x4C	; 76
 370:	88 83       	st	Y, r24
			spr->y_map = O_U_Y;
 372:	80 e1       	ldi	r24, 0x10	; 16
 374:	89 83       	std	Y+1, r24	; 0x01
			break;
		};
	}
 376:	df 91       	pop	r29
 378:	cf 91       	pop	r28
 37a:	08 95       	ret
			break;
		};
		//Drop a Z piece
		case(5):
		{
			spr->hght = Z_R_H;
 37c:	86 e0       	ldi	r24, 0x06	; 6
 37e:	8f 83       	std	Y+7, r24	; 0x07
			spr->wdth = Z_R_W;
 380:	84 e0       	ldi	r24, 0x04	; 4
 382:	8e 83       	std	Y+6, r24	; 0x06
			spr->x_map = Z_R_X;
 384:	8b e0       	ldi	r24, 0x0B	; 11
 386:	88 83       	st	Y, r24
			spr->y_map = Z_R_Y;
 388:	82 e1       	ldi	r24, 0x12	; 18
 38a:	89 83       	std	Y+1, r24	; 0x01
			spr->x_map = O_U_X;
			spr->y_map = O_U_Y;
			break;
		};
	}
 38c:	df 91       	pop	r29
 38e:	cf 91       	pop	r28
 390:	08 95       	ret
	switch(r_piece)
	{
		//Drop a J piece
		case(0):
		{
			spr->hght = J_R_H;
 392:	86 e0       	ldi	r24, 0x06	; 6
 394:	8f 83       	std	Y+7, r24	; 0x07
			spr->wdth = J_R_W;
 396:	84 e0       	ldi	r24, 0x04	; 4
 398:	8e 83       	std	Y+6, r24	; 0x06
			spr->x_map = J_R_X;
 39a:	84 e1       	ldi	r24, 0x14	; 20
 39c:	88 83       	st	Y, r24
			spr->y_map = J_R_Y;
 39e:	8d e0       	ldi	r24, 0x0D	; 13
 3a0:	89 83       	std	Y+1, r24	; 0x01
			spr->x_map = O_U_X;
			spr->y_map = O_U_Y;
			break;
		};
	}
 3a2:	df 91       	pop	r29
 3a4:	cf 91       	pop	r28
 3a6:	08 95       	ret
			break;
		};
		//Drop a L piece
		case(1):
		{
			spr->hght = L_L_H;
 3a8:	86 e0       	ldi	r24, 0x06	; 6
 3aa:	8f 83       	std	Y+7, r24	; 0x07
			spr->wdth = L_L_W;
 3ac:	84 e0       	ldi	r24, 0x04	; 4
 3ae:	8e 83       	std	Y+6, r24	; 0x06
			spr->x_map = L_L_X;
 3b0:	80 e2       	ldi	r24, 0x20	; 32
 3b2:	88 83       	st	Y, r24
			spr->y_map = L_L_Y;
 3b4:	8d e0       	ldi	r24, 0x0D	; 13
 3b6:	89 83       	std	Y+1, r24	; 0x01
			spr->x_map = O_U_X;
			spr->y_map = O_U_Y;
			break;
		};
	}
 3b8:	df 91       	pop	r29
 3ba:	cf 91       	pop	r28
 3bc:	08 95       	ret
			break;
		};
		//Drop a T piece
		case(2):
		{
			spr->hght = T_U_H;
 3be:	86 e0       	ldi	r24, 0x06	; 6
 3c0:	8f 83       	std	Y+7, r24	; 0x07
			spr->wdth = T_U_W;
 3c2:	84 e0       	ldi	r24, 0x04	; 4
 3c4:	8e 83       	std	Y+6, r24	; 0x06
			spr->x_map = T_U_X;
 3c6:	8f e3       	ldi	r24, 0x3F	; 63
 3c8:	88 83       	st	Y, r24
			spr->y_map = T_U_Y;
 3ca:	8d e0       	ldi	r24, 0x0D	; 13
 3cc:	89 83       	std	Y+1, r24	; 0x01
			spr->x_map = O_U_X;
			spr->y_map = O_U_Y;
			break;
		};
	}
 3ce:	df 91       	pop	r29
 3d0:	cf 91       	pop	r28
 3d2:	08 95       	ret
			break;
		};
		//Drop a I piece
		case(3):
		{
			spr->hght = I_U_H;
 3d4:	82 e0       	ldi	r24, 0x02	; 2
 3d6:	8f 83       	std	Y+7, r24	; 0x07
			spr->wdth = I_U_W;
 3d8:	88 e0       	ldi	r24, 0x08	; 8
 3da:	8e 83       	std	Y+6, r24	; 0x06
			spr->x_map = I_U_X;
 3dc:	8c e4       	ldi	r24, 0x4C	; 76
 3de:	88 83       	st	Y, r24
			spr->y_map = I_U_Y;
 3e0:	8d e0       	ldi	r24, 0x0D	; 13
 3e2:	89 83       	std	Y+1, r24	; 0x01
			spr->x_map = O_U_X;
			spr->y_map = O_U_Y;
			break;
		};
	}
 3e4:	df 91       	pop	r29
 3e6:	cf 91       	pop	r28
 3e8:	08 95       	ret
			break;
		};
		//Drop an S piece
		case(4):
		{
			spr->hght = S_R_H;
 3ea:	86 e0       	ldi	r24, 0x06	; 6
 3ec:	8f 83       	std	Y+7, r24	; 0x07
			spr->wdth = S_R_W;
 3ee:	84 e0       	ldi	r24, 0x04	; 4
 3f0:	8e 83       	std	Y+6, r24	; 0x06
			spr->x_map = S_R_X;
 3f2:	89 e1       	ldi	r24, 0x19	; 25
 3f4:	88 83       	st	Y, r24
			spr->y_map = S_R_Y;\
 3f6:	82 e1       	ldi	r24, 0x12	; 18
 3f8:	89 83       	std	Y+1, r24	; 0x01
			spr->x_map = O_U_X;
			spr->y_map = O_U_Y;
			break;
		};
	}
 3fa:	df 91       	pop	r29
 3fc:	cf 91       	pop	r28
 3fe:	08 95       	ret

00000400 <init_screen>:
	while(!(SPSR & (1<<SPIF)));

	//Pull DC low again if it was set high
	if(dc)
	{
		PORT_SPI &= ~(PORT_DC);
 400:	84 b1       	in	r24, 0x04	; 4
 402:	83 60       	ori	r24, 0x03	; 3
 404:	84 b9       	out	0x04, r24	; 4
 406:	28 9a       	sbi	0x05, 0	; 5
 408:	28 98       	cbi	0x05, 0	; 5
 40a:	28 9a       	sbi	0x05, 0	; 5
 40c:	81 e2       	ldi	r24, 0x21	; 33
 40e:	8e bd       	out	0x2e, r24	; 46
 410:	0d b4       	in	r0, 0x2d	; 45
 412:	07 fe       	sbrs	r0, 7
 414:	fd cf       	rjmp	.-6      	; 0x410 <init_screen+0x10>
 416:	80 e9       	ldi	r24, 0x90	; 144
 418:	8e bd       	out	0x2e, r24	; 46
 41a:	0d b4       	in	r0, 0x2d	; 45
 41c:	07 fe       	sbrs	r0, 7
 41e:	fd cf       	rjmp	.-6      	; 0x41a <init_screen+0x1a>
 420:	80 e2       	ldi	r24, 0x20	; 32
 422:	8e bd       	out	0x2e, r24	; 46
 424:	0d b4       	in	r0, 0x2d	; 45
 426:	07 fe       	sbrs	r0, 7
 428:	fd cf       	rjmp	.-6      	; 0x424 <init_screen+0x24>
 42a:	8c e0       	ldi	r24, 0x0C	; 12
 42c:	8e bd       	out	0x2e, r24	; 46
 42e:	0d b4       	in	r0, 0x2d	; 45
 430:	07 fe       	sbrs	r0, 7
 432:	fd cf       	rjmp	.-6      	; 0x42e <init_screen+0x2e>
 434:	80 e8       	ldi	r24, 0x80	; 128
 436:	8e bd       	out	0x2e, r24	; 46
 438:	0d b4       	in	r0, 0x2d	; 45
 43a:	07 fe       	sbrs	r0, 7
 43c:	fd cf       	rjmp	.-6      	; 0x438 <init_screen+0x38>
 43e:	80 e4       	ldi	r24, 0x40	; 64
 440:	8e bd       	out	0x2e, r24	; 46
 442:	0d b4       	in	r0, 0x2d	; 45
 444:	07 fe       	sbrs	r0, 7
 446:	fd cf       	rjmp	.-6      	; 0x442 <init_screen+0x42>
 448:	08 95       	ret

0000044a <blank_display>:
		send_byte(fbuff[i][x], DATA);
	}
}

void blank_display()
{
 44a:	89 ef       	ldi	r24, 0xF9	; 249
 44c:	91 e0       	ldi	r25, 0x01	; 1
	0x00, 0x0d, 0x0d, 0x3d, 0x3d, 0x31, 0x31, 0x00, 0x07, 0x07, 0x00, 0xf0, 0xf0, 0x3c, 0x3c, 0x00, 0x00, 0xc1, 0xc1, 0xf0, 0xf6, 0x36, 0x37, 0x07, 0x00, 0x3d, 0x3d, 0xf1, 0xf1, 0x01, 0x01, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x06, 0x06, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x01, 0x01, 0x07, 0x07, 0x00, 0x07, 0x07, 0x01, 0x01, 0x00, 0x1f, 0x1f, 0x00, 0x0f, 0x0f, 0x0f, 0x0f, 0x00, 0x00, 0x00, 0x00, 
};
void send_byte(uint8_t data, bool dc)
{
	// Load data into the buffer
	SPDR = data;
 44e:	1e bc       	out	0x2e, r1	; 46

	//If DC is high, pull the pin high
	if(dc)
	{
		PORT_SPI |= (PORT_DC);
 450:	29 9a       	sbi	0x05, 1	; 5
	}

	//Wait until transmission complete
	while(!(SPSR & (1<<SPIF)));
 452:	0d b4       	in	r0, 0x2d	; 45
 454:	07 fe       	sbrs	r0, 7
 456:	fd cf       	rjmp	.-6      	; 0x452 <blank_display+0x8>

	//Pull DC low again if it was set high
	if(dc)
	{
		PORT_SPI &= ~(PORT_DC);
 458:	29 98       	cbi	0x05, 1	; 5
 45a:	01 97       	sbiw	r24, 0x01	; 1
	do 
	{
		send_byte(0, DATA);
		--i;

	} while (i);
 45c:	c1 f7       	brne	.-16     	; 0x44e <blank_display+0x4>
}
 45e:	08 95       	ret

00000460 <read_pixel>:

//This function can read pixels in the spritemap or fbuff
bool read_pixel(uint8_t x, uint8_t y, uint8_t arr[][84])
{
	//Which byte to check
	uint8_t i = y/8;
 460:	96 2f       	mov	r25, r22
 462:	96 95       	lsr	r25
 464:	96 95       	lsr	r25
 466:	96 95       	lsr	r25
	uint8_t flag = 0x01;
	flag = flag << pos;

	//If there is a bit at that position, this will return true (pixel is black).
	//If there is no bit, this will return false (pixel is white)
	return arr[i][x] & flag;
 468:	24 e5       	ldi	r18, 0x54	; 84
 46a:	92 9f       	mul	r25, r18
 46c:	40 0d       	add	r20, r0
 46e:	51 1d       	adc	r21, r1
 470:	11 24       	eor	r1, r1
 472:	fa 01       	movw	r30, r20
 474:	e8 0f       	add	r30, r24
 476:	f1 1d       	adc	r31, r1
 478:	67 70       	andi	r22, 0x07	; 7
 47a:	81 e0       	ldi	r24, 0x01	; 1
 47c:	90 e0       	ldi	r25, 0x00	; 0
 47e:	01 c0       	rjmp	.+2      	; 0x482 <read_pixel+0x22>
 480:	88 0f       	add	r24, r24
 482:	6a 95       	dec	r22
 484:	ea f7       	brpl	.-6      	; 0x480 <read_pixel+0x20>
 486:	90 81       	ld	r25, Z
 488:	98 23       	and	r25, r24
 48a:	81 e0       	ldi	r24, 0x01	; 1
 48c:	09 f4       	brne	.+2      	; 0x490 <read_pixel+0x30>
 48e:	80 e0       	ldi	r24, 0x00	; 0
}
 490:	08 95       	ret

00000492 <clear_sprite>:

//Remove the sprite from the screen
void clear_sprite(struct sprite* spr)
{
 492:	cf 93       	push	r28
 494:	df 93       	push	r29
 496:	dc 01       	movw	r26, r24
	for(uint8_t y = 0; y < spr->hght; y++)
 498:	17 96       	adiw	r26, 0x07	; 7
 49a:	8c 91       	ld	r24, X
 49c:	17 97       	sbiw	r26, 0x07	; 7
 49e:	88 23       	and	r24, r24
 4a0:	09 f4       	brne	.+2      	; 0x4a4 <clear_sprite+0x12>
 4a2:	5b c0       	rjmp	.+182    	; 0x55a <clear_sprite+0xc8>
 4a4:	30 e0       	ldi	r19, 0x00	; 0
	uint8_t flag = 0x01;
	flag = flag << pos;

	//If there is a bit at that position, this will return true (pixel is black).
	//If there is no bit, this will return false (pixel is white)
	return arr[i][x] & flag;
 4a6:	64 e5       	ldi	r22, 0x54	; 84
	{
		set_ddram_y_addr(((spr->y_ppos + y)/8));
		for(uint8_t x = 0; x < spr->wdth; x++)
		{
			set_ddram_x_addr(spr->x_ppos + x);
			if(read_pixel(spr->x_map + x, spr->y_map + y, spritemap))
 4a8:	41 e0       	ldi	r20, 0x01	; 1
 4aa:	50 e0       	ldi	r21, 0x00	; 0

//Sets the y address in the screen's ddram. Note that this takes the address of the 
//BYTE of ddram you want to modify, not the index of the pixel you want to modify.
void set_ddram_y_addr(uint8_t y)
{
	send_byte((y | 0b01000000), COMM);
 4ac:	15 96       	adiw	r26, 0x05	; 5
 4ae:	2c 91       	ld	r18, X
 4b0:	15 97       	sbiw	r26, 0x05	; 5
 4b2:	83 2f       	mov	r24, r19
 4b4:	90 e0       	ldi	r25, 0x00	; 0
 4b6:	82 0f       	add	r24, r18
 4b8:	91 1d       	adc	r25, r1
 4ba:	95 95       	asr	r25
 4bc:	87 95       	ror	r24
 4be:	95 95       	asr	r25
 4c0:	87 95       	ror	r24
 4c2:	95 95       	asr	r25
 4c4:	87 95       	ror	r24
 4c6:	80 64       	ori	r24, 0x40	; 64
	0x00, 0x0d, 0x0d, 0x3d, 0x3d, 0x31, 0x31, 0x00, 0x07, 0x07, 0x00, 0xf0, 0xf0, 0x3c, 0x3c, 0x00, 0x00, 0xc1, 0xc1, 0xf0, 0xf6, 0x36, 0x37, 0x07, 0x00, 0x3d, 0x3d, 0xf1, 0xf1, 0x01, 0x01, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x06, 0x06, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x01, 0x01, 0x07, 0x07, 0x00, 0x07, 0x07, 0x01, 0x01, 0x00, 0x1f, 0x1f, 0x00, 0x0f, 0x0f, 0x0f, 0x0f, 0x00, 0x00, 0x00, 0x00, 
};
void send_byte(uint8_t data, bool dc)
{
	// Load data into the buffer
	SPDR = data;
 4c8:	8e bd       	out	0x2e, r24	; 46
	{
		PORT_SPI |= (PORT_DC);
	}

	//Wait until transmission complete
	while(!(SPSR & (1<<SPIF)));
 4ca:	0d b4       	in	r0, 0x2d	; 45
 4cc:	07 fe       	sbrs	r0, 7
 4ce:	fd cf       	rjmp	.-6      	; 0x4ca <clear_sprite+0x38>
void clear_sprite(struct sprite* spr)
{
	for(uint8_t y = 0; y < spr->hght; y++)
	{
		set_ddram_y_addr(((spr->y_ppos + y)/8));
		for(uint8_t x = 0; x < spr->wdth; x++)
 4d0:	16 96       	adiw	r26, 0x06	; 6
 4d2:	8c 91       	ld	r24, X
 4d4:	16 97       	sbiw	r26, 0x06	; 6
 4d6:	88 23       	and	r24, r24
 4d8:	c9 f1       	breq	.+114    	; 0x54c <clear_sprite+0xba>
 4da:	20 e0       	ldi	r18, 0x00	; 0
}

//Sets the x address in the screen's ddram
void set_ddram_x_addr(uint8_t x)
{
	send_byte((x | 0b10000000), COMM);
 4dc:	14 96       	adiw	r26, 0x04	; 4
 4de:	9c 91       	ld	r25, X
 4e0:	14 97       	sbiw	r26, 0x04	; 4
 4e2:	92 0f       	add	r25, r18
 4e4:	90 68       	ori	r25, 0x80	; 128
	0x00, 0x0d, 0x0d, 0x3d, 0x3d, 0x31, 0x31, 0x00, 0x07, 0x07, 0x00, 0xf0, 0xf0, 0x3c, 0x3c, 0x00, 0x00, 0xc1, 0xc1, 0xf0, 0xf6, 0x36, 0x37, 0x07, 0x00, 0x3d, 0x3d, 0xf1, 0xf1, 0x01, 0x01, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x06, 0x06, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x01, 0x01, 0x07, 0x07, 0x00, 0x07, 0x07, 0x01, 0x01, 0x00, 0x1f, 0x1f, 0x00, 0x0f, 0x0f, 0x0f, 0x0f, 0x00, 0x00, 0x00, 0x00, 
};
void send_byte(uint8_t data, bool dc)
{
	// Load data into the buffer
	SPDR = data;
 4e6:	9e bd       	out	0x2e, r25	; 46
	{
		PORT_SPI |= (PORT_DC);
	}

	//Wait until transmission complete
	while(!(SPSR & (1<<SPIF)));
 4e8:	0d b4       	in	r0, 0x2d	; 45
 4ea:	07 fe       	sbrs	r0, 7
 4ec:	fd cf       	rjmp	.-6      	; 0x4e8 <clear_sprite+0x56>
	{
		set_ddram_y_addr(((spr->y_ppos + y)/8));
		for(uint8_t x = 0; x < spr->wdth; x++)
		{
			set_ddram_x_addr(spr->x_ppos + x);
			if(read_pixel(spr->x_map + x, spr->y_map + y, spritemap))
 4ee:	11 96       	adiw	r26, 0x01	; 1
 4f0:	9c 91       	ld	r25, X
 4f2:	11 97       	sbiw	r26, 0x01	; 1
 4f4:	93 0f       	add	r25, r19

//This function can read pixels in the spritemap or fbuff
bool read_pixel(uint8_t x, uint8_t y, uint8_t arr[][84])
{
	//Which byte to check
	uint8_t i = y/8;
 4f6:	e9 2f       	mov	r30, r25
 4f8:	e6 95       	lsr	r30
 4fa:	e6 95       	lsr	r30
 4fc:	e6 95       	lsr	r30
	uint8_t flag = 0x01;
	flag = flag << pos;

	//If there is a bit at that position, this will return true (pixel is black).
	//If there is no bit, this will return false (pixel is white)
	return arr[i][x] & flag;
 4fe:	84 e5       	ldi	r24, 0x54	; 84
 500:	e8 9f       	mul	r30, r24
 502:	f0 01       	movw	r30, r0
 504:	11 24       	eor	r1, r1
 506:	ec 5f       	subi	r30, 0xFC	; 252
 508:	fe 4f       	sbci	r31, 0xFE	; 254
 50a:	8c 91       	ld	r24, X
 50c:	82 0f       	add	r24, r18
 50e:	e8 0f       	add	r30, r24
 510:	f1 1d       	adc	r31, r1
	{
		set_ddram_y_addr(((spr->y_ppos + y)/8));
		for(uint8_t x = 0; x < spr->wdth; x++)
		{
			set_ddram_x_addr(spr->x_ppos + x);
			if(read_pixel(spr->x_map + x, spr->y_map + y, spritemap))
 512:	97 70       	andi	r25, 0x07	; 7
 514:	ea 01       	movw	r28, r20
 516:	02 c0       	rjmp	.+4      	; 0x51c <clear_sprite+0x8a>
 518:	cc 0f       	add	r28, r28
 51a:	dd 1f       	adc	r29, r29
 51c:	9a 95       	dec	r25
 51e:	e2 f7       	brpl	.-8      	; 0x518 <clear_sprite+0x86>
 520:	ce 01       	movw	r24, r28
 522:	90 81       	ld	r25, Z
 524:	89 23       	and	r24, r25
 526:	61 f0       	breq	.+24     	; 0x540 <clear_sprite+0xae>
			{
				set_pixel(spr->x_ppos + x, spr->y_ppos + y, WHITE);
 528:	14 96       	adiw	r26, 0x04	; 4
 52a:	8c 91       	ld	r24, X
 52c:	14 97       	sbiw	r26, 0x04	; 4
 52e:	82 0f       	add	r24, r18
//buffer and sending the whole buffer to the screen, this function only changes
//the necessary pixels on the display. Note that the x and y address of the current
void set_pixel(uint8_t x, uint8_t y, bool color)
{
	//if out of bounds
	if(x > 83 || y > 47)
 530:	84 35       	cpi	r24, 0x54	; 84
 532:	30 f4       	brcc	.+12     	; 0x540 <clear_sprite+0xae>
		for(uint8_t x = 0; x < spr->wdth; x++)
		{
			set_ddram_x_addr(spr->x_ppos + x);
			if(read_pixel(spr->x_map + x, spr->y_map + y, spritemap))
			{
				set_pixel(spr->x_ppos + x, spr->y_ppos + y, WHITE);
 534:	15 96       	adiw	r26, 0x05	; 5
 536:	ec 91       	ld	r30, X
 538:	15 97       	sbiw	r26, 0x05	; 5
 53a:	e3 0f       	add	r30, r19
//buffer and sending the whole buffer to the screen, this function only changes
//the necessary pixels on the display. Note that the x and y address of the current
void set_pixel(uint8_t x, uint8_t y, bool color)
{
	//if out of bounds
	if(x > 83 || y > 47)
 53c:	e0 33       	cpi	r30, 0x30	; 48
 53e:	80 f0       	brcs	.+32     	; 0x560 <clear_sprite+0xce>
void clear_sprite(struct sprite* spr)
{
	for(uint8_t y = 0; y < spr->hght; y++)
	{
		set_ddram_y_addr(((spr->y_ppos + y)/8));
		for(uint8_t x = 0; x < spr->wdth; x++)
 540:	2f 5f       	subi	r18, 0xFF	; 255
 542:	16 96       	adiw	r26, 0x06	; 6
 544:	8c 91       	ld	r24, X
 546:	16 97       	sbiw	r26, 0x06	; 6
 548:	28 17       	cp	r18, r24
 54a:	40 f2       	brcs	.-112    	; 0x4dc <clear_sprite+0x4a>
}

//Remove the sprite from the screen
void clear_sprite(struct sprite* spr)
{
	for(uint8_t y = 0; y < spr->hght; y++)
 54c:	3f 5f       	subi	r19, 0xFF	; 255
 54e:	17 96       	adiw	r26, 0x07	; 7
 550:	8c 91       	ld	r24, X
 552:	17 97       	sbiw	r26, 0x07	; 7
 554:	38 17       	cp	r19, r24
 556:	08 f4       	brcc	.+2      	; 0x55a <clear_sprite+0xc8>
 558:	a9 cf       	rjmp	.-174    	; 0x4ac <clear_sprite+0x1a>
			{
				set_pixel(spr->x_ppos + x, spr->y_ppos + y, WHITE);
			}
		}
	}
}
 55a:	df 91       	pop	r29
 55c:	cf 91       	pop	r28
 55e:	08 95       	ret
	uint8_t i = y/8;
	//Which bit in the byte to manipulate
	uint8_t pos = y%8;
	//Positioning the byte for masking or oring
	uint8_t flag = 0x01;
	flag = flag << pos;
 560:	9e 2f       	mov	r25, r30
 562:	97 70       	andi	r25, 0x07	; 7
 564:	ea 01       	movw	r28, r20
 566:	01 c0       	rjmp	.+2      	; 0x56a <clear_sprite+0xd8>
 568:	cc 0f       	add	r28, r28
 56a:	9a 95       	dec	r25
 56c:	ea f7       	brpl	.-6      	; 0x568 <clear_sprite+0xd6>

	//If setting it white, mask and bitwise and
	else
	{
		flag = ~flag;
		fbuff[i][x] = fbuff[i][x] & flag;
 56e:	e6 95       	lsr	r30
 570:	e6 95       	lsr	r30
 572:	e6 95       	lsr	r30
 574:	c0 95       	com	r28
 576:	6e 9f       	mul	r22, r30
 578:	f0 01       	movw	r30, r0
 57a:	11 24       	eor	r1, r1
 57c:	e0 50       	subi	r30, 0x00	; 0
 57e:	fe 4f       	sbci	r31, 0xFE	; 254
 580:	e8 0f       	add	r30, r24
 582:	f1 1d       	adc	r31, r1
 584:	80 81       	ld	r24, Z
 586:	8c 23       	and	r24, r28
 588:	80 83       	st	Z, r24
	0x00, 0x0d, 0x0d, 0x3d, 0x3d, 0x31, 0x31, 0x00, 0x07, 0x07, 0x00, 0xf0, 0xf0, 0x3c, 0x3c, 0x00, 0x00, 0xc1, 0xc1, 0xf0, 0xf6, 0x36, 0x37, 0x07, 0x00, 0x3d, 0x3d, 0xf1, 0xf1, 0x01, 0x01, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x06, 0x06, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x01, 0x01, 0x07, 0x07, 0x00, 0x07, 0x07, 0x01, 0x01, 0x00, 0x1f, 0x1f, 0x00, 0x0f, 0x0f, 0x0f, 0x0f, 0x00, 0x00, 0x00, 0x00, 
};
void send_byte(uint8_t data, bool dc)
{
	// Load data into the buffer
	SPDR = data;
 58a:	8e bd       	out	0x2e, r24	; 46

	//If DC is high, pull the pin high
	if(dc)
	{
		PORT_SPI |= (PORT_DC);
 58c:	29 9a       	sbi	0x05, 1	; 5
	}

	//Wait until transmission complete
	while(!(SPSR & (1<<SPIF)));
 58e:	0d b4       	in	r0, 0x2d	; 45
 590:	07 fe       	sbrs	r0, 7
 592:	fd cf       	rjmp	.-6      	; 0x58e <clear_sprite+0xfc>

	//Pull DC low again if it was set high
	if(dc)
	{
		PORT_SPI &= ~(PORT_DC);
 594:	29 98       	cbi	0x05, 1	; 5
 596:	d4 cf       	rjmp	.-88     	; 0x540 <clear_sprite+0xae>

00000598 <draw_sprite>:
		}
	}
}

void draw_sprite(struct sprite* spr)
{
 598:	cf 93       	push	r28
 59a:	df 93       	push	r29
 59c:	ec 01       	movw	r28, r24
	clear_sprite(spr);
 59e:	0e 94 49 02 	call	0x492	; 0x492 <clear_sprite>
	for(uint8_t y = 0; y < spr->hght; y++)
 5a2:	8f 81       	ldd	r24, Y+7	; 0x07
 5a4:	88 23       	and	r24, r24
 5a6:	09 f4       	brne	.+2      	; 0x5aa <draw_sprite+0x12>
 5a8:	49 c0       	rjmp	.+146    	; 0x63c <draw_sprite+0xa4>
 5aa:	60 e0       	ldi	r22, 0x00	; 0
	uint8_t flag = 0x01;
	flag = flag << pos;

	//If there is a bit at that position, this will return true (pixel is black).
	//If there is no bit, this will return false (pixel is white)
	return arr[i][x] & flag;
 5ac:	74 e5       	ldi	r23, 0x54	; 84
	{
		set_ddram_y_addr(((spr->y_pos + y)/8));
		for(uint8_t x = 0; x < spr->wdth; x++)
		{
			set_ddram_x_addr(spr->x_pos + x);
			if(read_pixel(spr->x_map + x, spr->y_map + y, spritemap))
 5ae:	21 e0       	ldi	r18, 0x01	; 1
 5b0:	30 e0       	ldi	r19, 0x00	; 0

//Sets the y address in the screen's ddram. Note that this takes the address of the 
//BYTE of ddram you want to modify, not the index of the pixel you want to modify.
void set_ddram_y_addr(uint8_t y)
{
	send_byte((y | 0b01000000), COMM);
 5b2:	4b 81       	ldd	r20, Y+3	; 0x03
 5b4:	86 2f       	mov	r24, r22
 5b6:	90 e0       	ldi	r25, 0x00	; 0
 5b8:	84 0f       	add	r24, r20
 5ba:	91 1d       	adc	r25, r1
 5bc:	95 95       	asr	r25
 5be:	87 95       	ror	r24
 5c0:	95 95       	asr	r25
 5c2:	87 95       	ror	r24
 5c4:	95 95       	asr	r25
 5c6:	87 95       	ror	r24
 5c8:	80 64       	ori	r24, 0x40	; 64
	0x00, 0x0d, 0x0d, 0x3d, 0x3d, 0x31, 0x31, 0x00, 0x07, 0x07, 0x00, 0xf0, 0xf0, 0x3c, 0x3c, 0x00, 0x00, 0xc1, 0xc1, 0xf0, 0xf6, 0x36, 0x37, 0x07, 0x00, 0x3d, 0x3d, 0xf1, 0xf1, 0x01, 0x01, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x06, 0x06, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x01, 0x01, 0x07, 0x07, 0x00, 0x07, 0x07, 0x01, 0x01, 0x00, 0x1f, 0x1f, 0x00, 0x0f, 0x0f, 0x0f, 0x0f, 0x00, 0x00, 0x00, 0x00, 
};
void send_byte(uint8_t data, bool dc)
{
	// Load data into the buffer
	SPDR = data;
 5ca:	8e bd       	out	0x2e, r24	; 46
	{
		PORT_SPI |= (PORT_DC);
	}

	//Wait until transmission complete
	while(!(SPSR & (1<<SPIF)));
 5cc:	0d b4       	in	r0, 0x2d	; 45
 5ce:	07 fe       	sbrs	r0, 7
 5d0:	fd cf       	rjmp	.-6      	; 0x5cc <draw_sprite+0x34>
{
	clear_sprite(spr);
	for(uint8_t y = 0; y < spr->hght; y++)
	{
		set_ddram_y_addr(((spr->y_pos + y)/8));
		for(uint8_t x = 0; x < spr->wdth; x++)
 5d2:	8e 81       	ldd	r24, Y+6	; 0x06
 5d4:	88 23       	and	r24, r24
 5d6:	69 f1       	breq	.+90     	; 0x632 <draw_sprite+0x9a>
 5d8:	90 e0       	ldi	r25, 0x00	; 0
}

//Sets the x address in the screen's ddram
void set_ddram_x_addr(uint8_t x)
{
	send_byte((x | 0b10000000), COMM);
 5da:	8a 81       	ldd	r24, Y+2	; 0x02
 5dc:	89 0f       	add	r24, r25
 5de:	80 68       	ori	r24, 0x80	; 128
	0x00, 0x0d, 0x0d, 0x3d, 0x3d, 0x31, 0x31, 0x00, 0x07, 0x07, 0x00, 0xf0, 0xf0, 0x3c, 0x3c, 0x00, 0x00, 0xc1, 0xc1, 0xf0, 0xf6, 0x36, 0x37, 0x07, 0x00, 0x3d, 0x3d, 0xf1, 0xf1, 0x01, 0x01, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x06, 0x06, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x01, 0x01, 0x07, 0x07, 0x00, 0x07, 0x07, 0x01, 0x01, 0x00, 0x1f, 0x1f, 0x00, 0x0f, 0x0f, 0x0f, 0x0f, 0x00, 0x00, 0x00, 0x00, 
};
void send_byte(uint8_t data, bool dc)
{
	// Load data into the buffer
	SPDR = data;
 5e0:	8e bd       	out	0x2e, r24	; 46
	{
		PORT_SPI |= (PORT_DC);
	}

	//Wait until transmission complete
	while(!(SPSR & (1<<SPIF)));
 5e2:	0d b4       	in	r0, 0x2d	; 45
 5e4:	07 fe       	sbrs	r0, 7
 5e6:	fd cf       	rjmp	.-6      	; 0x5e2 <draw_sprite+0x4a>
	{
		set_ddram_y_addr(((spr->y_pos + y)/8));
		for(uint8_t x = 0; x < spr->wdth; x++)
		{
			set_ddram_x_addr(spr->x_pos + x);
			if(read_pixel(spr->x_map + x, spr->y_map + y, spritemap))
 5e8:	89 81       	ldd	r24, Y+1	; 0x01
 5ea:	86 0f       	add	r24, r22

//This function can read pixels in the spritemap or fbuff
bool read_pixel(uint8_t x, uint8_t y, uint8_t arr[][84])
{
	//Which byte to check
	uint8_t i = y/8;
 5ec:	e8 2f       	mov	r30, r24
 5ee:	e6 95       	lsr	r30
 5f0:	e6 95       	lsr	r30
 5f2:	e6 95       	lsr	r30
	uint8_t flag = 0x01;
	flag = flag << pos;

	//If there is a bit at that position, this will return true (pixel is black).
	//If there is no bit, this will return false (pixel is white)
	return arr[i][x] & flag;
 5f4:	44 e5       	ldi	r20, 0x54	; 84
 5f6:	e4 9f       	mul	r30, r20
 5f8:	f0 01       	movw	r30, r0
 5fa:	11 24       	eor	r1, r1
 5fc:	ec 5f       	subi	r30, 0xFC	; 252
 5fe:	fe 4f       	sbci	r31, 0xFE	; 254
 600:	48 81       	ld	r20, Y
 602:	49 0f       	add	r20, r25
 604:	e4 0f       	add	r30, r20
 606:	f1 1d       	adc	r31, r1
	{
		set_ddram_y_addr(((spr->y_pos + y)/8));
		for(uint8_t x = 0; x < spr->wdth; x++)
		{
			set_ddram_x_addr(spr->x_pos + x);
			if(read_pixel(spr->x_map + x, spr->y_map + y, spritemap))
 608:	87 70       	andi	r24, 0x07	; 7
 60a:	a9 01       	movw	r20, r18
 60c:	01 c0       	rjmp	.+2      	; 0x610 <draw_sprite+0x78>
 60e:	44 0f       	add	r20, r20
 610:	8a 95       	dec	r24
 612:	ea f7       	brpl	.-6      	; 0x60e <draw_sprite+0x76>
 614:	80 81       	ld	r24, Z
 616:	48 23       	and	r20, r24
 618:	41 f0       	breq	.+16     	; 0x62a <draw_sprite+0x92>
			{
				set_pixel(spr->x_pos + x, spr->y_pos + y, BLACK);
 61a:	8a 81       	ldd	r24, Y+2	; 0x02
 61c:	89 0f       	add	r24, r25
//buffer and sending the whole buffer to the screen, this function only changes
//the necessary pixels on the display. Note that the x and y address of the current
void set_pixel(uint8_t x, uint8_t y, bool color)
{
	//if out of bounds
	if(x > 83 || y > 47)
 61e:	84 35       	cpi	r24, 0x54	; 84
 620:	20 f4       	brcc	.+8      	; 0x62a <draw_sprite+0x92>
		for(uint8_t x = 0; x < spr->wdth; x++)
		{
			set_ddram_x_addr(spr->x_pos + x);
			if(read_pixel(spr->x_map + x, spr->y_map + y, spritemap))
			{
				set_pixel(spr->x_pos + x, spr->y_pos + y, BLACK);
 622:	4b 81       	ldd	r20, Y+3	; 0x03
 624:	46 0f       	add	r20, r22
//buffer and sending the whole buffer to the screen, this function only changes
//the necessary pixels on the display. Note that the x and y address of the current
void set_pixel(uint8_t x, uint8_t y, bool color)
{
	//if out of bounds
	if(x > 83 || y > 47)
 626:	40 33       	cpi	r20, 0x30	; 48
 628:	90 f0       	brcs	.+36     	; 0x64e <draw_sprite+0xb6>
{
	clear_sprite(spr);
	for(uint8_t y = 0; y < spr->hght; y++)
	{
		set_ddram_y_addr(((spr->y_pos + y)/8));
		for(uint8_t x = 0; x < spr->wdth; x++)
 62a:	9f 5f       	subi	r25, 0xFF	; 255
 62c:	8e 81       	ldd	r24, Y+6	; 0x06
 62e:	98 17       	cp	r25, r24
 630:	a0 f2       	brcs	.-88     	; 0x5da <draw_sprite+0x42>
}

void draw_sprite(struct sprite* spr)
{
	clear_sprite(spr);
	for(uint8_t y = 0; y < spr->hght; y++)
 632:	6f 5f       	subi	r22, 0xFF	; 255
 634:	8f 81       	ldd	r24, Y+7	; 0x07
 636:	68 17       	cp	r22, r24
 638:	08 f4       	brcc	.+2      	; 0x63c <draw_sprite+0xa4>
 63a:	bb cf       	rjmp	.-138    	; 0x5b2 <draw_sprite+0x1a>
			{
				set_pixel(spr->x_pos + x, spr->y_pos + y, BLACK);
			}
		}
	}
	spr->x_ppos = spr->x_pos;
 63c:	8a 81       	ldd	r24, Y+2	; 0x02
 63e:	8c 83       	std	Y+4, r24	; 0x04
	spr->y_ppos = spr->y_pos;
 640:	8b 81       	ldd	r24, Y+3	; 0x03
 642:	8d 83       	std	Y+5, r24	; 0x05
	//Check to see if the sprite is now colliding with something
	check_collision(spr);
 644:	ce 01       	movw	r24, r28

}
 646:	df 91       	pop	r29
 648:	cf 91       	pop	r28
		}
	}
	spr->x_ppos = spr->x_pos;
	spr->y_ppos = spr->y_pos;
	//Check to see if the sprite is now colliding with something
	check_collision(spr);
 64a:	0c 94 5a 00 	jmp	0xb4	; 0xb4 <check_collision>

	//If setting it black, bitwise or
	if(color)
	{
		//write the changes to the internal fbuff
		fbuff[i][x] = fbuff[i][x] | flag;
 64e:	e4 2f       	mov	r30, r20
 650:	e6 95       	lsr	r30
 652:	e6 95       	lsr	r30
 654:	e6 95       	lsr	r30
 656:	47 70       	andi	r20, 0x07	; 7
 658:	d9 01       	movw	r26, r18
 65a:	02 c0       	rjmp	.+4      	; 0x660 <draw_sprite+0xc8>
 65c:	aa 0f       	add	r26, r26
 65e:	bb 1f       	adc	r27, r27
 660:	4a 95       	dec	r20
 662:	e2 f7       	brpl	.-8      	; 0x65c <draw_sprite+0xc4>
 664:	ad 01       	movw	r20, r26
 666:	7e 9f       	mul	r23, r30
 668:	f0 01       	movw	r30, r0
 66a:	11 24       	eor	r1, r1
 66c:	e0 50       	subi	r30, 0x00	; 0
 66e:	fe 4f       	sbci	r31, 0xFE	; 254
 670:	e8 0f       	add	r30, r24
 672:	f1 1d       	adc	r31, r1
 674:	80 81       	ld	r24, Z
 676:	48 2b       	or	r20, r24
 678:	40 83       	st	Z, r20
	0x00, 0x0d, 0x0d, 0x3d, 0x3d, 0x31, 0x31, 0x00, 0x07, 0x07, 0x00, 0xf0, 0xf0, 0x3c, 0x3c, 0x00, 0x00, 0xc1, 0xc1, 0xf0, 0xf6, 0x36, 0x37, 0x07, 0x00, 0x3d, 0x3d, 0xf1, 0xf1, 0x01, 0x01, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x06, 0x06, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x01, 0x01, 0x07, 0x07, 0x00, 0x07, 0x07, 0x01, 0x01, 0x00, 0x1f, 0x1f, 0x00, 0x0f, 0x0f, 0x0f, 0x0f, 0x00, 0x00, 0x00, 0x00, 
};
void send_byte(uint8_t data, bool dc)
{
	// Load data into the buffer
	SPDR = data;
 67a:	4e bd       	out	0x2e, r20	; 46

	//If DC is high, pull the pin high
	if(dc)
	{
		PORT_SPI |= (PORT_DC);
 67c:	29 9a       	sbi	0x05, 1	; 5
	}

	//Wait until transmission complete
	while(!(SPSR & (1<<SPIF)));
 67e:	0d b4       	in	r0, 0x2d	; 45
 680:	07 fe       	sbrs	r0, 7
 682:	fd cf       	rjmp	.-6      	; 0x67e <draw_sprite+0xe6>

	//Pull DC low again if it was set high
	if(dc)
	{
		PORT_SPI &= ~(PORT_DC);
 684:	29 98       	cbi	0x05, 1	; 5
 686:	d1 cf       	rjmp	.-94     	; 0x62a <draw_sprite+0x92>

00000688 <main>:
#include <stdint.h>

#include "game.h"

int main(void)
{
 688:	cf 93       	push	r28
 68a:	df 93       	push	r29
 68c:	cd b7       	in	r28, 0x3d	; 61
 68e:	de b7       	in	r29, 0x3e	; 62
 690:	29 97       	sbiw	r28, 0x09	; 9
 692:	0f b6       	in	r0, 0x3f	; 63
 694:	f8 94       	cli
 696:	de bf       	out	0x3e, r29	; 62
 698:	0f be       	out	0x3f, r0	; 63
 69a:	cd bf       	out	0x3d, r28	; 61
	struct sprite tmino;
	tmino.x_pos = X_ORIGIN;
 69c:	9c e3       	ldi	r25, 0x3C	; 60
 69e:	9b 83       	std	Y+3, r25	; 0x03
	tmino.y_pos = Y_ORIGIN;
 6a0:	84 e1       	ldi	r24, 0x14	; 20
 6a2:	8c 83       	std	Y+4, r24	; 0x04
	tmino.x_ppos = X_ORIGIN;
 6a4:	9d 83       	std	Y+5, r25	; 0x05
	tmino.y_ppos = Y_ORIGIN;
 6a6:	8e 83       	std	Y+6, r24	; 0x06
	sjsu.str = sjsu_s;
	sjsu.x_pos = 6;
	sjsu.y_pos = 48;
*/
	//Initialize the SPI bus
	spi_init_master();
 6a8:	0e 94 6b 03 	call	0x6d6	; 0x6d6 <spi_init_master>
	//Initialize the screen
	init_screen();
 6ac:	0e 94 00 02 	call	0x400	; 0x400 <init_screen>
	//Initialize the random number generator
	init_rand();
 6b0:	0e 94 87 01 	call	0x30e	; 0x30e <init_rand>
	//White out the display
	blank_display();
 6b4:	0e 94 25 02 	call	0x44a	; 0x44a <blank_display>
	set_pixel(10, 3, BLACK);
	set_ddram_x_addr(10);
	set_ddram_y_addr(0/8);
	set_pixel(10, 4, BLACK);
	*/
	spawn_new_tmino(&tmino);
 6b8:	ce 01       	movw	r24, r28
 6ba:	01 96       	adiw	r24, 0x01	; 1
 6bc:	0e 94 9b 01 	call	0x336	; 0x336 <spawn_new_tmino>
	//draw_string(&sjsu);
	//_delay_ms(10);
	
	while(1)
	{
		if(!(tmino.coll & LFT_COLL_BIT))
 6c0:	89 85       	ldd	r24, Y+9	; 0x09
 6c2:	83 fd       	sbrc	r24, 3
 6c4:	f9 cf       	rjmp	.-14     	; 0x6b8 <main+0x30>
		{
			soft_drop(&tmino);
 6c6:	ce 01       	movw	r24, r28
 6c8:	01 96       	adiw	r24, 0x01	; 1
 6ca:	0e 94 95 01 	call	0x32a	; 0x32a <soft_drop>
	//draw_string(&sjsu);
	//_delay_ms(10);
	
	while(1)
	{
		if(!(tmino.coll & LFT_COLL_BIT))
 6ce:	89 85       	ldd	r24, Y+9	; 0x09
 6d0:	83 fd       	sbrc	r24, 3
 6d2:	f2 cf       	rjmp	.-28     	; 0x6b8 <main+0x30>
 6d4:	f8 cf       	rjmp	.-16     	; 0x6c6 <main+0x3e>

000006d6 <spi_init_master>:

// Initialize SPI Master Device (with SPI interrupt)
void spi_init_master (void)
{
	// Set MOSI, SCK, SS as Output
	DDR_SPI=(1<<DD_MOSI)|(1<<DD_SCK)|(1<<DD_SS);
 6d6:	8c e2       	ldi	r24, 0x2C	; 44
 6d8:	84 b9       	out	0x04, r24	; 4

	// Enable SPI, Set as Master
	// Prescaler: Fosc/16, Enable Interrupts
	SPCR=(1<<SPE)|(1<<MSTR)|(1<<SPR0);
 6da:	81 e5       	ldi	r24, 0x51	; 81
 6dc:	8c bd       	out	0x2c, r24	; 44
 6de:	08 95       	ret

000006e0 <__tablejump2__>:
 6e0:	ee 0f       	add	r30, r30
 6e2:	ff 1f       	adc	r31, r31
 6e4:	05 90       	lpm	r0, Z+
 6e6:	f4 91       	lpm	r31, Z
 6e8:	e0 2d       	mov	r30, r0
 6ea:	09 94       	ijmp

000006ec <do_rand>:
 6ec:	8f 92       	push	r8
 6ee:	9f 92       	push	r9
 6f0:	af 92       	push	r10
 6f2:	bf 92       	push	r11
 6f4:	cf 92       	push	r12
 6f6:	df 92       	push	r13
 6f8:	ef 92       	push	r14
 6fa:	ff 92       	push	r15
 6fc:	cf 93       	push	r28
 6fe:	df 93       	push	r29
 700:	ec 01       	movw	r28, r24
 702:	68 81       	ld	r22, Y
 704:	79 81       	ldd	r23, Y+1	; 0x01
 706:	8a 81       	ldd	r24, Y+2	; 0x02
 708:	9b 81       	ldd	r25, Y+3	; 0x03
 70a:	61 15       	cp	r22, r1
 70c:	71 05       	cpc	r23, r1
 70e:	81 05       	cpc	r24, r1
 710:	91 05       	cpc	r25, r1
 712:	21 f4       	brne	.+8      	; 0x71c <do_rand+0x30>
 714:	64 e2       	ldi	r22, 0x24	; 36
 716:	79 ed       	ldi	r23, 0xD9	; 217
 718:	8b e5       	ldi	r24, 0x5B	; 91
 71a:	97 e0       	ldi	r25, 0x07	; 7
 71c:	2d e1       	ldi	r18, 0x1D	; 29
 71e:	33 ef       	ldi	r19, 0xF3	; 243
 720:	41 e0       	ldi	r20, 0x01	; 1
 722:	50 e0       	ldi	r21, 0x00	; 0
 724:	0e 94 ed 03 	call	0x7da	; 0x7da <__divmodsi4>
 728:	49 01       	movw	r8, r18
 72a:	5a 01       	movw	r10, r20
 72c:	9b 01       	movw	r18, r22
 72e:	ac 01       	movw	r20, r24
 730:	a7 ea       	ldi	r26, 0xA7	; 167
 732:	b1 e4       	ldi	r27, 0x41	; 65
 734:	0e 94 0c 04 	call	0x818	; 0x818 <__muluhisi3>
 738:	6b 01       	movw	r12, r22
 73a:	7c 01       	movw	r14, r24
 73c:	ac ee       	ldi	r26, 0xEC	; 236
 73e:	b4 ef       	ldi	r27, 0xF4	; 244
 740:	a5 01       	movw	r20, r10
 742:	94 01       	movw	r18, r8
 744:	0e 94 1a 04 	call	0x834	; 0x834 <__mulohisi3>
 748:	dc 01       	movw	r26, r24
 74a:	cb 01       	movw	r24, r22
 74c:	8c 0d       	add	r24, r12
 74e:	9d 1d       	adc	r25, r13
 750:	ae 1d       	adc	r26, r14
 752:	bf 1d       	adc	r27, r15
 754:	b7 ff       	sbrs	r27, 7
 756:	03 c0       	rjmp	.+6      	; 0x75e <do_rand+0x72>
 758:	01 97       	sbiw	r24, 0x01	; 1
 75a:	a1 09       	sbc	r26, r1
 75c:	b0 48       	sbci	r27, 0x80	; 128
 75e:	88 83       	st	Y, r24
 760:	99 83       	std	Y+1, r25	; 0x01
 762:	aa 83       	std	Y+2, r26	; 0x02
 764:	bb 83       	std	Y+3, r27	; 0x03
 766:	9f 77       	andi	r25, 0x7F	; 127
 768:	df 91       	pop	r29
 76a:	cf 91       	pop	r28
 76c:	ff 90       	pop	r15
 76e:	ef 90       	pop	r14
 770:	df 90       	pop	r13
 772:	cf 90       	pop	r12
 774:	bf 90       	pop	r11
 776:	af 90       	pop	r10
 778:	9f 90       	pop	r9
 77a:	8f 90       	pop	r8
 77c:	08 95       	ret

0000077e <rand_r>:
 77e:	0e 94 76 03 	call	0x6ec	; 0x6ec <do_rand>
 782:	08 95       	ret

00000784 <rand>:
 784:	80 e0       	ldi	r24, 0x00	; 0
 786:	91 e0       	ldi	r25, 0x01	; 1
 788:	0e 94 76 03 	call	0x6ec	; 0x6ec <do_rand>
 78c:	08 95       	ret

0000078e <srand>:
 78e:	a0 e0       	ldi	r26, 0x00	; 0
 790:	b0 e0       	ldi	r27, 0x00	; 0
 792:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__data_start>
 796:	90 93 01 01 	sts	0x0101, r25	; 0x800101 <__data_start+0x1>
 79a:	a0 93 02 01 	sts	0x0102, r26	; 0x800102 <__data_start+0x2>
 79e:	b0 93 03 01 	sts	0x0103, r27	; 0x800103 <__data_start+0x3>
 7a2:	08 95       	ret

000007a4 <eeprom_write_dword>:
 7a4:	24 2f       	mov	r18, r20
 7a6:	0e 94 e0 03 	call	0x7c0	; 0x7c0 <eeprom_write_r18>
 7aa:	25 2f       	mov	r18, r21
 7ac:	0e 94 e0 03 	call	0x7c0	; 0x7c0 <eeprom_write_r18>
 7b0:	0c 94 da 03 	jmp	0x7b4	; 0x7b4 <eeprom_write_word>

000007b4 <eeprom_write_word>:
 7b4:	0e 94 df 03 	call	0x7be	; 0x7be <eeprom_write_byte>
 7b8:	27 2f       	mov	r18, r23
 7ba:	0c 94 e0 03 	jmp	0x7c0	; 0x7c0 <eeprom_write_r18>

000007be <eeprom_write_byte>:
 7be:	26 2f       	mov	r18, r22

000007c0 <eeprom_write_r18>:
 7c0:	f9 99       	sbic	0x1f, 1	; 31
 7c2:	fe cf       	rjmp	.-4      	; 0x7c0 <eeprom_write_r18>
 7c4:	1f ba       	out	0x1f, r1	; 31
 7c6:	92 bd       	out	0x22, r25	; 34
 7c8:	81 bd       	out	0x21, r24	; 33
 7ca:	20 bd       	out	0x20, r18	; 32
 7cc:	0f b6       	in	r0, 0x3f	; 63
 7ce:	f8 94       	cli
 7d0:	fa 9a       	sbi	0x1f, 2	; 31
 7d2:	f9 9a       	sbi	0x1f, 1	; 31
 7d4:	0f be       	out	0x3f, r0	; 63
 7d6:	01 96       	adiw	r24, 0x01	; 1
 7d8:	08 95       	ret

000007da <__divmodsi4>:
 7da:	05 2e       	mov	r0, r21
 7dc:	97 fb       	bst	r25, 7
 7de:	1e f4       	brtc	.+6      	; 0x7e6 <__divmodsi4+0xc>
 7e0:	00 94       	com	r0
 7e2:	0e 94 04 04 	call	0x808	; 0x808 <__negsi2>
 7e6:	57 fd       	sbrc	r21, 7
 7e8:	07 d0       	rcall	.+14     	; 0x7f8 <__divmodsi4_neg2>
 7ea:	0e 94 1f 04 	call	0x83e	; 0x83e <__udivmodsi4>
 7ee:	07 fc       	sbrc	r0, 7
 7f0:	03 d0       	rcall	.+6      	; 0x7f8 <__divmodsi4_neg2>
 7f2:	4e f4       	brtc	.+18     	; 0x806 <__divmodsi4_exit>
 7f4:	0c 94 04 04 	jmp	0x808	; 0x808 <__negsi2>

000007f8 <__divmodsi4_neg2>:
 7f8:	50 95       	com	r21
 7fa:	40 95       	com	r20
 7fc:	30 95       	com	r19
 7fe:	21 95       	neg	r18
 800:	3f 4f       	sbci	r19, 0xFF	; 255
 802:	4f 4f       	sbci	r20, 0xFF	; 255
 804:	5f 4f       	sbci	r21, 0xFF	; 255

00000806 <__divmodsi4_exit>:
 806:	08 95       	ret

00000808 <__negsi2>:
 808:	90 95       	com	r25
 80a:	80 95       	com	r24
 80c:	70 95       	com	r23
 80e:	61 95       	neg	r22
 810:	7f 4f       	sbci	r23, 0xFF	; 255
 812:	8f 4f       	sbci	r24, 0xFF	; 255
 814:	9f 4f       	sbci	r25, 0xFF	; 255
 816:	08 95       	ret

00000818 <__muluhisi3>:
 818:	0e 94 41 04 	call	0x882	; 0x882 <__umulhisi3>
 81c:	a5 9f       	mul	r26, r21
 81e:	90 0d       	add	r25, r0
 820:	b4 9f       	mul	r27, r20
 822:	90 0d       	add	r25, r0
 824:	a4 9f       	mul	r26, r20
 826:	80 0d       	add	r24, r0
 828:	91 1d       	adc	r25, r1
 82a:	11 24       	eor	r1, r1
 82c:	08 95       	ret

0000082e <__mulshisi3>:
 82e:	b7 ff       	sbrs	r27, 7
 830:	0c 94 0c 04 	jmp	0x818	; 0x818 <__muluhisi3>

00000834 <__mulohisi3>:
 834:	0e 94 0c 04 	call	0x818	; 0x818 <__muluhisi3>
 838:	82 1b       	sub	r24, r18
 83a:	93 0b       	sbc	r25, r19
 83c:	08 95       	ret

0000083e <__udivmodsi4>:
 83e:	a1 e2       	ldi	r26, 0x21	; 33
 840:	1a 2e       	mov	r1, r26
 842:	aa 1b       	sub	r26, r26
 844:	bb 1b       	sub	r27, r27
 846:	fd 01       	movw	r30, r26
 848:	0d c0       	rjmp	.+26     	; 0x864 <__udivmodsi4_ep>

0000084a <__udivmodsi4_loop>:
 84a:	aa 1f       	adc	r26, r26
 84c:	bb 1f       	adc	r27, r27
 84e:	ee 1f       	adc	r30, r30
 850:	ff 1f       	adc	r31, r31
 852:	a2 17       	cp	r26, r18
 854:	b3 07       	cpc	r27, r19
 856:	e4 07       	cpc	r30, r20
 858:	f5 07       	cpc	r31, r21
 85a:	20 f0       	brcs	.+8      	; 0x864 <__udivmodsi4_ep>
 85c:	a2 1b       	sub	r26, r18
 85e:	b3 0b       	sbc	r27, r19
 860:	e4 0b       	sbc	r30, r20
 862:	f5 0b       	sbc	r31, r21

00000864 <__udivmodsi4_ep>:
 864:	66 1f       	adc	r22, r22
 866:	77 1f       	adc	r23, r23
 868:	88 1f       	adc	r24, r24
 86a:	99 1f       	adc	r25, r25
 86c:	1a 94       	dec	r1
 86e:	69 f7       	brne	.-38     	; 0x84a <__udivmodsi4_loop>
 870:	60 95       	com	r22
 872:	70 95       	com	r23
 874:	80 95       	com	r24
 876:	90 95       	com	r25
 878:	9b 01       	movw	r18, r22
 87a:	ac 01       	movw	r20, r24
 87c:	bd 01       	movw	r22, r26
 87e:	cf 01       	movw	r24, r30
 880:	08 95       	ret

00000882 <__umulhisi3>:
 882:	a2 9f       	mul	r26, r18
 884:	b0 01       	movw	r22, r0
 886:	b3 9f       	mul	r27, r19
 888:	c0 01       	movw	r24, r0
 88a:	a3 9f       	mul	r26, r19
 88c:	70 0d       	add	r23, r0
 88e:	81 1d       	adc	r24, r1
 890:	11 24       	eor	r1, r1
 892:	91 1d       	adc	r25, r1
 894:	b2 9f       	mul	r27, r18
 896:	70 0d       	add	r23, r0
 898:	81 1d       	adc	r24, r1
 89a:	11 24       	eor	r1, r1
 89c:	91 1d       	adc	r25, r1
 89e:	08 95       	ret

000008a0 <_exit>:
 8a0:	f8 94       	cli

000008a2 <__stop_program>:
 8a2:	ff cf       	rjmp	.-2      	; 0x8a2 <__stop_program>
