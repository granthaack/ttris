   1               		.file	"ttris.cpp"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.stabs	"/home/granthaack/Documents/ttris/",100,0,4,.Ltext0
   8               		.stabs	"ttris.cpp",100,0,4,.Ltext0
   9               		.text
  10               	.Ltext0:
  11               		.stabs	"gcc2_compiled.",60,0,0,0
  12               		.stabs	"__uint24:t(0,1)=@s24;r(0,1);0;077777777;",128,0,0,0
  13               		.stabs	"__int24:t(0,2)=@s24;r(0,2);040000000;037777777;",128,0,0,0
  14               		.stabs	"__builtin_va_list:t(0,3)=*(0,4)=(0,4)",128,0,0,0
  15               		.stabs	"complex long double:t(0,5)=R3;8;0;",128,0,0,0
  16               		.stabs	"complex double:t(0,6)=R3;8;0;",128,0,0,0
  17               		.stabs	"complex float:t(0,7)=R3;8;0;",128,0,0,0
  18               		.stabs	"complex int:t(0,8)=s4real:(0,9)=r(0,9);-32768;32767;,0,16;imag:(0,9),16,16;;",128,0,0,0
  19               		.stabs	"long long unsigned int:t(0,10)=@s64;r(0,10);0;01777777777777777777777;",128,0,0,0
  20               		.stabs	"long unsigned int:t(0,11)=@s32;r(0,11);0;037777777777;",128,0,0,0
  21               		.stabs	"unsigned int:t(0,12)=r(0,12);0;0177777;",128,0,0,0
  22               		.stabs	"unsigned char:t(0,13)=@s8;r(0,13);0;255;",128,0,0,0
  23               		.stabs	"long long int:t(0,14)=@s64;r(0,14);01000000000000000000000;0777777777777777777777;",128,0,
  24               		.stabs	"long int:t(0,15)=@s32;r(0,15);020000000000;017777777777;",128,0,0,0
  25               		.stabs	"int:t(0,9)",128,0,0,0
  26               		.stabs	"signed char:t(0,16)=@s8;r(0,16);-128;127;",128,0,0,0
  27               		.stabs	"char:t(0,17)=r(0,17);0;127;",128,0,0,0
  28               		.stabs	"signed:t(0,9)",128,0,0,0
  29               		.stabs	"unsigned long:t(0,11)",128,0,0,0
  30               		.stabs	"long long unsigned:t(0,10)",128,0,0,0
  31               		.stabs	"short int:t(0,18)=r(0,18);-32768;32767;",128,0,0,0
  32               		.stabs	"short unsigned int:t(0,19)=r(0,19);0;0177777;",128,0,0,0
  33               		.stabs	"unsigned short:t(0,19)",128,0,0,0
  34               		.stabs	"float:t(0,20)=r(0,9);4;0;",128,0,0,0
  35               		.stabs	"double:t(0,21)=r(0,9);4;0;",128,0,0,0
  36               		.stabs	"long double:t(0,22)=r(0,9);4;0;",128,0,0,0
  37               		.stabs	"short _Fract:t(0,23)=r(0,9);1;0;",128,0,0,0
  38               		.stabs	"long _Fract:t(0,24)=r(0,9);4;0;",128,0,0,0
  39               		.stabs	"long long _Fract:t(0,25)=r(0,9);8;0;",128,0,0,0
  40               		.stabs	"unsigned short _Fract:t(0,26)=r(0,9);1;0;",128,0,0,0
  41               		.stabs	"unsigned _Fract:t(0,27)=r(0,9);2;0;",128,0,0,0
  42               		.stabs	"unsigned long _Fract:t(0,28)=r(0,9);4;0;",128,0,0,0
  43               		.stabs	"unsigned long long _Fract:t(0,29)=r(0,9);8;0;",128,0,0,0
  44               		.stabs	"_Sat short _Fract:t(0,30)=r(0,9);1;0;",128,0,0,0
  45               		.stabs	"_Sat _Fract:t(0,31)=r(0,9);2;0;",128,0,0,0
  46               		.stabs	"_Sat long _Fract:t(0,32)=r(0,9);4;0;",128,0,0,0
  47               		.stabs	"_Sat long long _Fract:t(0,33)=r(0,9);8;0;",128,0,0,0
  48               		.stabs	"_Sat unsigned short _Fract:t(0,34)=r(0,9);1;0;",128,0,0,0
  49               		.stabs	"_Sat unsigned _Fract:t(0,35)=r(0,9);2;0;",128,0,0,0
  50               		.stabs	"_Sat unsigned long _Fract:t(0,36)=r(0,9);4;0;",128,0,0,0
  51               		.stabs	"_Sat unsigned long long _Fract:t(0,37)=r(0,9);8;0;",128,0,0,0
  52               		.stabs	"short _Accum:t(0,38)=r(0,9);2;0;",128,0,0,0
  53               		.stabs	"long _Accum:t(0,39)=r(0,9);8;0;",128,0,0,0
  54               		.stabs	"long long _Accum:t(0,40)=r(0,9);8;0;",128,0,0,0
  55               		.stabs	"unsigned short _Accum:t(0,41)=r(0,9);2;0;",128,0,0,0
  56               		.stabs	"unsigned _Accum:t(0,42)=r(0,9);4;0;",128,0,0,0
  57               		.stabs	"unsigned long _Accum:t(0,43)=r(0,9);8;0;",128,0,0,0
  58               		.stabs	"unsigned long long _Accum:t(0,44)=r(0,9);8;0;",128,0,0,0
  59               		.stabs	"_Sat short _Accum:t(0,45)=r(0,9);2;0;",128,0,0,0
  60               		.stabs	"_Sat _Accum:t(0,46)=r(0,9);4;0;",128,0,0,0
  61               		.stabs	"_Sat long _Accum:t(0,47)=r(0,9);8;0;",128,0,0,0
  62               		.stabs	"_Sat long long _Accum:t(0,48)=r(0,9);8;0;",128,0,0,0
  63               		.stabs	"_Sat unsigned short _Accum:t(0,49)=r(0,9);2;0;",128,0,0,0
  64               		.stabs	"_Sat unsigned _Accum:t(0,50)=r(0,9);4;0;",128,0,0,0
  65               		.stabs	"_Sat unsigned long _Accum:t(0,51)=r(0,9);8;0;",128,0,0,0
  66               		.stabs	"_Sat unsigned long long _Accum:t(0,52)=r(0,9);8;0;",128,0,0,0
  67               		.stabs	"void:t(0,4)",128,0,0,0
  68               		.stabs	"wchar_t:t(0,53)=r(0,53);-32768;32767;",128,0,0,0
  69               		.stabs	"bool:t(0,54)=@s8;-16;",128,0,0,0
  70               		.stabs	"__vtbl_ptr_type:t(0,55)=*(0,56)=f(0,9)",128,0,0,0
  71               		.stabs	"decltype(nullptr):t(0,57)=(0,57)",128,0,0,0
  72               		.stabs	"int8_t:t(0,58)=(0,16)",128,0,121,0
  73               		.stabs	"uint8_t:t(0,59)=(0,13)",128,0,122,0
  74               		.stabs	"int16_t:t(0,60)=(0,9)",128,0,123,0
  75               		.stabs	"uint16_t:t(0,61)=(0,12)",128,0,124,0
  76               		.stabs	"int32_t:t(0,62)=(0,15)",128,0,125,0
  77               		.stabs	"uint32_t:t(0,63)=(0,11)",128,0,126,0
  78               		.stabs	"int64_t:t(0,64)=(0,14)",128,0,128,0
  79               		.stabs	"uint64_t:t(0,65)=(0,10)",128,0,129,0
  80               		.stabs	"intptr_t:t(0,66)=(0,60)",128,0,142,0
  81               		.stabs	"uintptr_t:t(0,67)=(0,61)",128,0,147,0
  82               		.stabs	"int_least8_t:t(0,68)=(0,58)",128,0,159,0
  83               		.stabs	"uint_least8_t:t(0,69)=(0,59)",128,0,164,0
  84               		.stabs	"int_least16_t:t(0,70)=(0,60)",128,0,169,0
  85               		.stabs	"uint_least16_t:t(0,71)=(0,61)",128,0,174,0
  86               		.stabs	"int_least32_t:t(0,72)=(0,62)",128,0,179,0
  87               		.stabs	"uint_least32_t:t(0,73)=(0,63)",128,0,184,0
  88               		.stabs	"int_least64_t:t(0,74)=(0,64)",128,0,192,0
  89               		.stabs	"uint_least64_t:t(0,75)=(0,65)",128,0,199,0
  90               		.stabs	"int_fast8_t:t(0,76)=(0,58)",128,0,213,0
  91               		.stabs	"uint_fast8_t:t(0,77)=(0,59)",128,0,218,0
  92               		.stabs	"int_fast16_t:t(0,78)=(0,60)",128,0,223,0
  93               		.stabs	"uint_fast16_t:t(0,79)=(0,61)",128,0,228,0
  94               		.stabs	"int_fast32_t:t(0,80)=(0,62)",128,0,233,0
  95               		.stabs	"uint_fast32_t:t(0,81)=(0,63)",128,0,238,0
  96               		.stabs	"int_fast64_t:t(0,82)=(0,64)",128,0,246,0
  97               		.stabs	"uint_fast64_t:t(0,83)=(0,65)",128,0,253,0
  98               		.stabs	"intmax_t:t(0,84)=(0,64)",128,0,273,0
  99               		.stabs	"uintmax_t:t(0,85)=(0,65)",128,0,278,0
 100               		.stabs	"int_farptr_t:t(0,86)=(0,62)",128,0,77,0
 101               		.stabs	"uint_farptr_t:t(0,87)=(0,63)",128,0,81,0
 102               		.stabs	"._0:Tt(0,88)=s3low:(0,13),0,8;high:(0,13),8,8;extended:(0,13),16,8;;",128,0,240,0
 103               		.stabs	"__fuse_t:t(0,88)",128,0,244,0
 104               		.stabs	"byte:t(0,89)=(0,13)",128,0,7,0
 105               		.stabs	"_Z15spi_init_masterv:F(0,4)",36,0,51,_Z15spi_init_masterv
 106               	.global	_Z15spi_init_masterv
 107               		.type	_Z15spi_init_masterv, @function
 108               	_Z15spi_init_masterv:
 109               		.stabd	46,0,0
   1:ttris.cpp     **** #define F_CPU  16000000UL
   2:ttris.cpp     **** 
   3:ttris.cpp     **** #include <avr/io.h>
   4:ttris.cpp     **** #include <util/delay.h>
   5:ttris.cpp     **** #include <avr/interrupt.h>
   6:ttris.cpp     **** 
   7:ttris.cpp     **** typedef unsigned char byte;
   8:ttris.cpp     **** 
   9:ttris.cpp     **** #define HIGH 1
  10:ttris.cpp     **** #define LOW 0
  11:ttris.cpp     **** 
  12:ttris.cpp     **** #define BLACK 1
  13:ttris.cpp     **** #define WHITE 0
  14:ttris.cpp     **** 
  15:ttris.cpp     **** #define DATA 1
  16:ttris.cpp     **** #define COMM 0
  17:ttris.cpp     **** 
  18:ttris.cpp     **** //Define the SPI Pins to communicate with the screen
  19:ttris.cpp     **** //Define the data direction registers
  20:ttris.cpp     **** #define DDR_SPI         DDRB
  21:ttris.cpp     **** #define DD_SCK          DDB5
  22:ttris.cpp     **** #define DD_MISO         DDB4
  23:ttris.cpp     **** #define DD_MOSI         DDB3
  24:ttris.cpp     **** #define DD_SS           DDB2
  25:ttris.cpp     **** #define DD_DC           DDB1
  26:ttris.cpp     **** #define DD_RST          DDB0
  27:ttris.cpp     **** 
  28:ttris.cpp     **** //Define the port registers
  29:ttris.cpp     **** #define PORT_SPI        PORTB
  30:ttris.cpp     **** #define PORT_SCK        (1 << PB5) //yellow
  31:ttris.cpp     **** #define PORT_MISO       (1 << PB4) //green (unused)
  32:ttris.cpp     **** #define PORT_MOSI       (1 << PB3) //white
  33:ttris.cpp     **** #define PORT_SS         (1 << PB2) //orange
  34:ttris.cpp     **** #define PORT_DC         (1 << PB1) //blue
  35:ttris.cpp     **** #define PORT_RST        (1 << PB0) //green
  36:ttris.cpp     **** 
  37:ttris.cpp     **** //Init the video buffer
  38:ttris.cpp     **** byte vbuff[6][84] = {
  39:ttris.cpp     ****   /*
  40:ttris.cpp     **** 0x4c, 0xaa, 0xec, 0xaa, 0xac, 0x00, 0xaa, 0xee, 0xee, 0xae, 0xaa, 0x00, 0xae, 0xa2, 0x44, 0x48, 0x4
  41:ttris.cpp     **** */
  42:ttris.cpp     **** 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0
  43:ttris.cpp     **** 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0
  44:ttris.cpp     **** 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0
  45:ttris.cpp     **** 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0
  46:ttris.cpp     **** 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0
  47:ttris.cpp     **** 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0
  48:ttris.cpp     **** };
  49:ttris.cpp     **** 
  50:ttris.cpp     **** // Initialize SPI Master Device (with SPI interrupt)
  51:ttris.cpp     **** void spi_init_master (void)
  52:ttris.cpp     **** {
 110               		.stabn	68,0,52,.LM0-.LFBB1
 111               	.LM0:
 112               	.LFBB1:
 113               	/* prologue: function */
 114               	/* frame size = 0 */
 115               	/* stack size = 0 */
 116               	.L__stack_usage = 0
  53:ttris.cpp     ****     // Set MOSI, SCK, SS, DC, and RST as Output
  54:ttris.cpp     ****     DDR_SPI=(1<<DD_MOSI)|(1<<DD_SCK)|(1<<DD_SS)|(1<<DD_DC)|(1<<DD_RST);
 117               		.stabn	68,0,54,.LM1-.LFBB1
 118               	.LM1:
 119 0000 8FE2      		ldi r24,lo8(47)
 120 0002 84B9      		out 0x4,r24
  55:ttris.cpp     **** 
  56:ttris.cpp     ****     // Enable SPI, Set as Master
  57:ttris.cpp     ****     // Prescaler: Fosc/16, Enable Interrupts
  58:ttris.cpp     ****     //The MOSI, SCK pins are as per ATMega8
  59:ttris.cpp     ****     SPCR=(1<<SPE)|(1<<MSTR)|(1<<SPR0);
 121               		.stabn	68,0,59,.LM2-.LFBB1
 122               	.LM2:
 123 0004 81E5      		ldi r24,lo8(81)
 124 0006 8CBD      		out 0x2c,r24
 125 0008 0895      		ret
 126               		.size	_Z15spi_init_masterv, .-_Z15spi_init_masterv
 127               	.Lscope1:
 128               		.stabs	"",36,0,0,.Lscope1-.LFBB1
 129               		.stabd	78,0,0
 130               		.stabs	"_Z9send_bytehb:F(0,4)",36,0,63,_Z9send_bytehb
 131               		.stabs	"data:P(0,89)",64,0,63,24
 132               		.stabs	"dc:P(0,54)",64,0,63,22
 133               	.global	_Z9send_bytehb
 134               		.type	_Z9send_bytehb, @function
 135               	_Z9send_bytehb:
 136               		.stabd	46,0,0
  60:ttris.cpp     **** }
  61:ttris.cpp     **** 
  62:ttris.cpp     **** //Function to send and receive data for both master and slave
  63:ttris.cpp     **** void send_byte(byte data, bool dc)
  64:ttris.cpp     **** {
 137               		.stabn	68,0,64,.LM3-.LFBB2
 138               	.LM3:
 139               	.LFBB2:
 140               	/* prologue: function */
 141               	/* frame size = 0 */
 142               	/* stack size = 0 */
 143               	.L__stack_usage = 0
  65:ttris.cpp     ****     // Load data into the buffer
  66:ttris.cpp     ****     SPDR = data;
 144               		.stabn	68,0,66,.LM4-.LFBB2
 145               	.LM4:
 146 000a 8EBD      		out 0x2e,r24
  67:ttris.cpp     **** 
  68:ttris.cpp     ****     //If DC is high, pull the pin high
  69:ttris.cpp     ****     if(dc)
 147               		.stabn	68,0,69,.LM5-.LFBB2
 148               	.LM5:
 149 000c 6111      		cpse r22,__zero_reg__
  70:ttris.cpp     ****     {
  71:ttris.cpp     ****       PORT_SPI |= (PORT_DC);
 150               		.stabn	68,0,71,.LM6-.LFBB2
 151               	.LM6:
 152 000e 299A      		sbi 0x5,1
 153               	.L4:
  72:ttris.cpp     ****     }
  73:ttris.cpp     **** 
  74:ttris.cpp     ****     //Wait until transmission complete
  75:ttris.cpp     ****     while(!(SPSR & (1<<SPIF)));
 154               		.stabn	68,0,75,.LM7-.LFBB2
 155               	.LM7:
 156 0010 0DB4      		in __tmp_reg__,0x2d
 157 0012 07FE      		sbrs __tmp_reg__,7
 158 0014 00C0      		rjmp .L4
  76:ttris.cpp     **** 
  77:ttris.cpp     ****     //Pull DC low again if it was set high
  78:ttris.cpp     ****     if(dc)
 159               		.stabn	68,0,78,.LM8-.LFBB2
 160               	.LM8:
 161 0016 6111      		cpse r22,__zero_reg__
 162               	.LBB14:
 163               	.LBB15:
  79:ttris.cpp     ****     {
  80:ttris.cpp     ****       PORT_SPI &= ~(PORT_DC);
 164               		.stabn	68,0,80,.LM9-.LFBB2
 165               	.LM9:
 166 0018 2998      		cbi 0x5,1
 167               	.L2:
 168 001a 0895      		ret
 169               	.LBE15:
 170               	.LBE14:
 171               		.size	_Z9send_bytehb, .-_Z9send_bytehb
 172               	.Lscope2:
 173               		.stabs	"",36,0,0,.Lscope2-.LFBB2
 174               		.stabd	78,0,0
 175               		.stabs	"_Z11init_screenv:F(0,4)",36,0,85,_Z11init_screenv
 176               	.global	_Z11init_screenv
 177               		.type	_Z11init_screenv, @function
 178               	_Z11init_screenv:
 179               		.stabd	46,0,0
  81:ttris.cpp     ****     }
  82:ttris.cpp     ****     return;
  83:ttris.cpp     **** }
  84:ttris.cpp     **** 
  85:ttris.cpp     **** void init_screen(void)
  86:ttris.cpp     **** {
 180               		.stabn	68,0,86,.LM10-.LFBB3
 181               	.LM10:
 182               	.LFBB3:
 183               	/* prologue: function */
 184               	/* frame size = 0 */
 185               	/* stack size = 0 */
 186               	.L__stack_usage = 0
  87:ttris.cpp     ****   //Toggle the reset pin then set it high
  88:ttris.cpp     ****   PORT_SPI |= (PORT_RST);
 187               		.stabn	68,0,88,.LM11-.LFBB3
 188               	.LM11:
 189 001c 289A      		sbi 0x5,0
  89:ttris.cpp     ****   PORT_SPI &= ~(PORT_RST);
 190               		.stabn	68,0,89,.LM12-.LFBB3
 191               	.LM12:
 192 001e 2898      		cbi 0x5,0
  90:ttris.cpp     ****   PORT_SPI |= (PORT_RST);
 193               		.stabn	68,0,90,.LM13-.LFBB3
 194               	.LM13:
 195 0020 289A      		sbi 0x5,0
  91:ttris.cpp     **** 
  92:ttris.cpp     ****   //send a byte to init function set
  93:ttris.cpp     ****   send_byte(0b00100001, COMM);
 196               		.stabn	68,0,93,.LM14-.LFBB3
 197               	.LM14:
 198 0022 60E0      		ldi r22,0
 199 0024 81E2      		ldi r24,lo8(33)
 200 0026 0E94 0000 		call _Z9send_bytehb
  94:ttris.cpp     ****   //send byte to init Vop
  95:ttris.cpp     ****   send_byte(0b10010000, COMM);
 201               		.stabn	68,0,95,.LM15-.LFBB3
 202               	.LM15:
 203 002a 60E0      		ldi r22,0
 204 002c 80E9      		ldi r24,lo8(-112)
 205 002e 0E94 0000 		call _Z9send_bytehb
  96:ttris.cpp     ****   //send byte to select normal instruction set
  97:ttris.cpp     ****   send_byte(0b00100000, COMM);
 206               		.stabn	68,0,97,.LM16-.LFBB3
 207               	.LM16:
 208 0032 60E0      		ldi r22,0
 209 0034 80E2      		ldi r24,lo8(32)
 210 0036 0E94 0000 		call _Z9send_bytehb
  98:ttris.cpp     ****   //send byte to set screen to normal mode
  99:ttris.cpp     ****   send_byte(0b00001100, COMM);
 211               		.stabn	68,0,99,.LM17-.LFBB3
 212               	.LM17:
 213 003a 60E0      		ldi r22,0
 214 003c 8CE0      		ldi r24,lo8(12)
 215 003e 0E94 0000 		call _Z9send_bytehb
 100:ttris.cpp     ****   //set x DDRAM address to 0
 101:ttris.cpp     ****   send_byte(0b10000000, COMM);
 216               		.stabn	68,0,101,.LM18-.LFBB3
 217               	.LM18:
 218 0042 60E0      		ldi r22,0
 219 0044 80E8      		ldi r24,lo8(-128)
 220 0046 0E94 0000 		call _Z9send_bytehb
 102:ttris.cpp     ****   //set y DDRAM address to 0
 103:ttris.cpp     ****   send_byte(0b01000000, COMM);
 221               		.stabn	68,0,103,.LM19-.LFBB3
 222               	.LM19:
 223 004a 60E0      		ldi r22,0
 224 004c 80E4      		ldi r24,lo8(64)
 225 004e 0C94 0000 		jmp _Z9send_bytehb
 226               		.size	_Z11init_screenv, .-_Z11init_screenv
 227               	.Lscope3:
 228               		.stabs	"",36,0,0,.Lscope3-.LFBB3
 229               		.stabd	78,0,0
 230               		.stabs	"_Z9set_pixeliib:F(0,4)",36,0,124,_Z9set_pixeliib
 231               		.stabs	"x:P(0,9)",64,0,124,24
 232               		.stabs	"y:P(0,9)",64,0,124,22
 233               		.stabs	"color:P(0,54)",64,0,124,20
 234               	.global	_Z9set_pixeliib
 235               		.type	_Z9set_pixeliib, @function
 236               	_Z9set_pixeliib:
 237               		.stabd	46,0,0
 104:ttris.cpp     **** }
 105:ttris.cpp     **** 
 106:ttris.cpp     **** //Explanation on this function and why it seems so complex:
 107:ttris.cpp     **** //Common sense would dictate that the way updating the display would work is
 108:ttris.cpp     **** //the programmer would change a value in the internal vbuff, and then the entire
 109:ttris.cpp     **** //vbuff would be sent to to the screen as a single frame. However, this means
 110:ttris.cpp     **** //that each time you render a frame, 504 bytes are sent over the wire, no matter
 111:ttris.cpp     **** //how small the change to the fram was. If you only changed 1 byte, this is a
 112:ttris.cpp     **** //huge waste of bandwidth.
 113:ttris.cpp     **** //
 114:ttris.cpp     **** //The way this function works is it only updates the pixels that actually
 115:ttris.cpp     **** //change. It sets the x and y location of the DDRAM in the display and then
 116:ttris.cpp     **** //writes the appropriate data to that single byte only. This is done in 3 bytes
 117:ttris.cpp     **** //instead of 504.
 118:ttris.cpp     **** //
 119:ttris.cpp     **** // vbuff must still be maintained in memory however since the display
 120:ttris.cpp     **** //can't send data back, and you can only update one byte at a time. If you
 121:ttris.cpp     **** //update a single bit, all the other bits in that byte would get overwritten on
 122:ttris.cpp     **** //the screen.
 123:ttris.cpp     **** 
 124:ttris.cpp     **** void set_pixel(int x, int y, bool color)
 125:ttris.cpp     **** {
 238               		.stabn	68,0,125,.LM20-.LFBB4
 239               	.LM20:
 240               	.LFBB4:
 241 0052 0F93      		push r16
 242 0054 1F93      		push r17
 243 0056 CF93      		push r28
 244 0058 DF93      		push r29
 245               	/* prologue: function */
 246               	/* frame size = 0 */
 247               	/* stack size = 4 */
 248               	.L__stack_usage = 4
 249               	.LBB23:
 126:ttris.cpp     ****   //if out of bounds
 127:ttris.cpp     ****   if(x > 83 || y > 47)
 250               		.stabn	68,0,127,.LM21-.LFBB4
 251               	.LM21:
 252 005a 8435      		cpi r24,84
 253 005c 9105      		cpc r25,__zero_reg__
 254 005e 04F4      		brge .L15
 255               		.stabn	68,0,127,.LM22-.LFBB4
 256               	.LM22:
 257 0060 6033      		cpi r22,48
 258 0062 7105      		cpc r23,__zero_reg__
 259 0064 04F4      		brge .L15
 260               	.LBE23:
 261               	.LBB24:
 262               	.LBB25:
 128:ttris.cpp     ****   {
 129:ttris.cpp     ****     return;
 130:ttris.cpp     ****   }
 131:ttris.cpp     **** 
 132:ttris.cpp     ****   //Which byte to manipulate
 133:ttris.cpp     ****   int i = y/8;
 263               		.stabn	68,0,133,.LM23-.LFBB4
 264               	.LM23:
 265 0066 FB01      		movw r30,r22
 266 0068 77FD      		sbrc r23,7
 267 006a 3796      		adiw r30,7
 268               	.L17:
 269 006c 9C01      		movw r18,r24
 270 006e 83E0      		ldi r24,3
 271               		1:
 272 0070 F595      		asr r31
 273 0072 E795      		ror r30
 274 0074 8A95      		dec r24
 275 0076 01F4      		brne 1b
 134:ttris.cpp     ****   //Which bit in the byte to manipulate
 135:ttris.cpp     ****   int pos = y%8;
 276               		.stabn	68,0,135,.LM24-.LFBB4
 277               	.LM24:
 278 0078 CB01      		movw r24,r22
 279 007a 68E0      		ldi r22,lo8(8)
 280 007c 70E0      		ldi r23,0
 281 007e 0E94 0000 		call __divmodhi4
 136:ttris.cpp     ****   //Positioning the byte for masking or oring
 137:ttris.cpp     ****   byte flag = 0x01;
 138:ttris.cpp     ****   flag = flag << pos;
 282               		.stabn	68,0,138,.LM25-.LFBB4
 283               	.LM25:
 284 0082 61E0      		ldi r22,lo8(1)
 285 0084 70E0      		ldi r23,0
 286 0086 00C0      		rjmp 2f
 287               		1:
 288 0088 660F      		lsl r22
 289               		2:
 290 008a 8A95      		dec r24
 291 008c 02F4      		brpl 1b
 292 008e CF01      		movw r24,r30
 293 0090 8064      		ori r24,64
 294 0092 8901      		movw r16,r18
 295 0094 0068      		ori r16,128
 296               	.LBB26:
 297               	.LBB27:
 139:ttris.cpp     **** 
 140:ttris.cpp     ****   //If setting it black, bitwise or
 141:ttris.cpp     ****   if(color)
 142:ttris.cpp     ****   {
 143:ttris.cpp     ****     //write the changes to the internal vbuff
 144:ttris.cpp     ****     vbuff[i][x] = vbuff[i][x] | flag;
 298               		.stabn	68,0,144,.LM26-.LFBB4
 299               	.LM26:
 300 0096 94E5      		ldi r25,lo8(84)
 301 0098 9E9F      		mul r25,r30
 302 009a E001      		movw r28,r0
 303 009c 9F9F      		mul r25,r31
 304 009e D00D      		add r29,r0
 305 00a0 1124      		clr __zero_reg__
 306 00a2 C20F      		add r28,r18
 307 00a4 D31F      		adc r29,r19
 308 00a6 C050      		subi r28,lo8(-(vbuff))
 309 00a8 D040      		sbci r29,hi8(-(vbuff))
 310               	.LBE27:
 141:ttris.cpp     ****   {
 311               		.stabn	68,0,141,.LM27-.LFBB4
 312               	.LM27:
 313 00aa 4423      		tst r20
 314 00ac 01F0      		breq .L18
 315               	.LBB28:
 316               		.stabn	68,0,144,.LM28-.LFBB4
 317               	.LM28:
 318 00ae 9881      		ld r25,Y
 319 00b0 692B      		or r22,r25
 320 00b2 00C0      		rjmp .L19
 321               	.L18:
 322               	.LBE28:
 323               	.LBB29:
 145:ttris.cpp     **** 
 146:ttris.cpp     ****     //update the y address
 147:ttris.cpp     ****     int sendy = i | 0b01000000;
 148:ttris.cpp     ****     send_byte(sendy, COMM);
 149:ttris.cpp     ****     //update the x address
 150:ttris.cpp     ****     int sendx = x | 0b10000000;
 151:ttris.cpp     ****     send_byte(sendx, COMM);
 152:ttris.cpp     **** 
 153:ttris.cpp     ****     //Send the updated byte to the screen
 154:ttris.cpp     ****     send_byte(vbuff[i][x], DATA);
 155:ttris.cpp     **** 
 156:ttris.cpp     ****   }
 157:ttris.cpp     **** 
 158:ttris.cpp     ****   //If setting it white, mask and bitwise and
 159:ttris.cpp     ****   else
 160:ttris.cpp     ****   {
 161:ttris.cpp     ****     flag = ~flag;
 324               		.stabn	68,0,161,.LM29-.LFBB4
 325               	.LM29:
 326 00b4 6095      		com r22
 162:ttris.cpp     ****     vbuff[i][x] = vbuff[i][x] & flag;
 327               		.stabn	68,0,162,.LM30-.LFBB4
 328               	.LM30:
 329 00b6 9881      		ld r25,Y
 330 00b8 6923      		and r22,r25
 331               	.L19:
 332 00ba 6883      		st Y,r22
 163:ttris.cpp     **** 
 164:ttris.cpp     ****     //update the y address
 165:ttris.cpp     ****     int sendy = i | 0b01000000;
 166:ttris.cpp     ****     send_byte(sendy, COMM);
 333               		.stabn	68,0,166,.LM31-.LFBB4
 334               	.LM31:
 335 00bc 60E0      		ldi r22,0
 336 00be 0E94 0000 		call _Z9send_bytehb
 167:ttris.cpp     ****     //update the x address
 168:ttris.cpp     ****     int sendx = x | 0b10000000;
 169:ttris.cpp     ****     send_byte(sendx, COMM);
 337               		.stabn	68,0,169,.LM32-.LFBB4
 338               	.LM32:
 339 00c2 60E0      		ldi r22,0
 340 00c4 802F      		mov r24,r16
 341 00c6 0E94 0000 		call _Z9send_bytehb
 170:ttris.cpp     **** 
 171:ttris.cpp     ****     //Send the updated byte to the screen
 172:ttris.cpp     ****     send_byte(vbuff[i][x], DATA);
 342               		.stabn	68,0,172,.LM33-.LFBB4
 343               	.LM33:
 344 00ca 61E0      		ldi r22,lo8(1)
 345 00cc 8881      		ld r24,Y
 346               	/* epilogue start */
 347               	.LBE29:
 348               	.LBE26:
 349               	.LBE25:
 350               	.LBE24:
 173:ttris.cpp     ****   }
 174:ttris.cpp     **** }
 351               		.stabn	68,0,174,.LM34-.LFBB4
 352               	.LM34:
 353 00ce DF91      		pop r29
 354 00d0 CF91      		pop r28
 355 00d2 1F91      		pop r17
 356 00d4 0F91      		pop r16
 357               	.LBB33:
 358               	.LBB32:
 359               	.LBB31:
 360               	.LBB30:
 172:ttris.cpp     ****   }
 361               		.stabn	68,0,172,.LM35-.LFBB4
 362               	.LM35:
 363 00d6 0C94 0000 		jmp _Z9send_bytehb
 364               	.L15:
 365               	/* epilogue start */
 366               	.LBE30:
 367               	.LBE31:
 368               	.LBE32:
 369               	.LBE33:
 370               		.stabn	68,0,174,.LM36-.LFBB4
 371               	.LM36:
 372 00da DF91      		pop r29
 373 00dc CF91      		pop r28
 374 00de 1F91      		pop r17
 375 00e0 0F91      		pop r16
 376 00e2 0895      		ret
 377               		.size	_Z9set_pixeliib, .-_Z9set_pixeliib
 378               	.Lscope4:
 379               		.stabs	"",36,0,0,.Lscope4-.LFBB4
 380               		.stabd	78,0,0
 381               		.stabs	"_Z13blank_displayv:F(0,4)",36,0,176,_Z13blank_displayv
 382               	.global	_Z13blank_displayv
 383               		.type	_Z13blank_displayv, @function
 384               	_Z13blank_displayv:
 385               		.stabd	46,0,0
 175:ttris.cpp     **** 
 176:ttris.cpp     **** void blank_display(){
 386               		.stabn	68,0,176,.LM37-.LFBB5
 387               	.LM37:
 388               	.LFBB5:
 389 00e4 CF93      		push r28
 390 00e6 DF93      		push r29
 391               	/* prologue: function */
 392               	/* frame size = 0 */
 393               	/* stack size = 2 */
 394               	.L__stack_usage = 2
 395               		.stabn	68,0,176,.LM38-.LFBB5
 396               	.LM38:
 397 00e8 C8EF      		ldi r28,lo8(-8)
 398 00ea D1E0      		ldi r29,lo8(1)
 399               	.L21:
 400               	.LBB34:
 177:ttris.cpp     ****   for(int i = 0; i < 504; i++)
 178:ttris.cpp     ****   {
 179:ttris.cpp     ****     send_byte(0, DATA);
 401               		.stabn	68,0,179,.LM39-.LFBB5
 402               	.LM39:
 403 00ec 61E0      		ldi r22,lo8(1)
 404 00ee 80E0      		ldi r24,0
 405 00f0 0E94 0000 		call _Z9send_bytehb
 406 00f4 2197      		sbiw r28,1
 177:ttris.cpp     ****   for(int i = 0; i < 504; i++)
 407               		.stabn	68,0,177,.LM40-.LFBB5
 408               	.LM40:
 409 00f6 01F4      		brne .L21
 410               	/* epilogue start */
 411               	.LBE34:
 180:ttris.cpp     ****   }
 181:ttris.cpp     **** }
 412               		.stabn	68,0,181,.LM41-.LFBB5
 413               	.LM41:
 414 00f8 DF91      		pop r29
 415 00fa CF91      		pop r28
 416 00fc 0895      		ret
 417               		.size	_Z13blank_displayv, .-_Z13blank_displayv
 418               	.Lscope5:
 419               		.stabs	"",36,0,0,.Lscope5-.LFBB5
 420               		.stabd	78,0,0
 421               		.section	.text.startup,"ax",@progbits
 422               		.stabs	"main:F(0,9)",36,0,183,main
 423               	.global	main
 424               		.type	main, @function
 425               	main:
 426               		.stabd	46,0,0
 182:ttris.cpp     **** 
 183:ttris.cpp     **** int main(void)
 184:ttris.cpp     **** {
 427               		.stabn	68,0,184,.LM42-.LFBB6
 428               	.LM42:
 429               	.LFBB6:
 430 0000 EF92      		push r14
 431 0002 FF92      		push r15
 432 0004 0F93      		push r16
 433 0006 1F93      		push r17
 434 0008 CF93      		push r28
 435 000a DF93      		push r29
 436               	/* prologue: function */
 437               	/* frame size = 0 */
 438               	/* stack size = 6 */
 439               	.L__stack_usage = 6
 440               	.LBB35:
 441               	.LBB36:
 442               	.LBB37:
 443               		.stabs	"/usr/lib/avr/include/util/delay.h",132,0,0,.Ltext1
 444               	.Ltext1:
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/lib/avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/lib/avr/include/util/delay.h **** #endif
  41:/usr/lib/avr/include/util/delay.h **** 
  42:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  45:/usr/lib/avr/include/util/delay.h **** 
  46:/usr/lib/avr/include/util/delay.h **** /** \file */
  47:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/lib/avr/include/util/delay.h ****     \code
  49:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/lib/avr/include/util/delay.h ****     \endcode
  53:/usr/lib/avr/include/util/delay.h **** 
  54:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/lib/avr/include/util/delay.h ****     used.
  58:/usr/lib/avr/include/util/delay.h **** 
  59:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/lib/avr/include/util/delay.h **** 
  68:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/lib/avr/include/util/delay.h **** 
  77:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/lib/avr/include/util/delay.h **** 
  81:/usr/lib/avr/include/util/delay.h **** */
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/lib/avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/lib/avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/lib/avr/include/util/delay.h **** #endif
  87:/usr/lib/avr/include/util/delay.h **** 
  88:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/lib/avr/include/util/delay.h **** #endif
  93:/usr/lib/avr/include/util/delay.h **** 
  94:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/lib/avr/include/util/delay.h **** #endif
  97:/usr/lib/avr/include/util/delay.h **** 
  98:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 102:/usr/lib/avr/include/util/delay.h **** #endif
 103:/usr/lib/avr/include/util/delay.h **** 
 104:/usr/lib/avr/include/util/delay.h **** /**
 105:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/lib/avr/include/util/delay.h **** 
 107:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/lib/avr/include/util/delay.h **** 
 109:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/lib/avr/include/util/delay.h **** 
 112:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/lib/avr/include/util/delay.h **** 
 114:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/lib/avr/include/util/delay.h **** 
 120:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/lib/avr/include/util/delay.h **** 
 125:/usr/lib/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/lib/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/lib/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/lib/avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/lib/avr/include/util/delay.h **** 
 132:/usr/lib/avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/lib/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/lib/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/lib/avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/lib/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/lib/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/lib/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/lib/avr/include/util/delay.h **** 
 140:/usr/lib/avr/include/util/delay.h ****  */
 141:/usr/lib/avr/include/util/delay.h **** void
 142:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/lib/avr/include/util/delay.h **** {
 144:/usr/lib/avr/include/util/delay.h **** 	double __tmp ; 
 145:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 146:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 147:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 148:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 149:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 150:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 151:/usr/lib/avr/include/util/delay.h **** 
 152:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 153:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 154:/usr/lib/avr/include/util/delay.h **** 
 155:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 156:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 157:/usr/lib/avr/include/util/delay.h **** 
 158:/usr/lib/avr/include/util/delay.h **** 	#else
 159:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 160:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 161:/usr/lib/avr/include/util/delay.h **** 	#endif
 162:/usr/lib/avr/include/util/delay.h **** 
 163:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 445               		.stabn	68,0,163,.LM43-.LFBB6
 446               	.LM43:
 447 000c 2FEF      		ldi r18,lo8(639999)
 448 000e 83EC      		ldi r24,hi8(639999)
 449 0010 99E0      		ldi r25,hlo8(639999)
 450 0012 2150      	1:	subi r18,1
 451 0014 8040      		sbci r24,0
 452 0016 9040      		sbci r25,0
 453 0018 01F4      		brne 1b
 454 001a 00C0      		rjmp .
 455 001c 0000      		nop
 456               	.LBE37:
 457               	.LBE36:
 458               		.stabs	"ttris.cpp",132,0,0,.Ltext2
 459               	.Ltext2:
 185:ttris.cpp     ****   //Give the AVR a bit to boot
 186:ttris.cpp     ****   _delay_ms(200);
 187:ttris.cpp     ****   //Initialize the SPI bus
 188:ttris.cpp     ****   spi_init_master();
 460               		.stabn	68,0,188,.LM44-.LFBB6
 461               	.LM44:
 462 001e 0E94 0000 		call _Z15spi_init_masterv
 189:ttris.cpp     ****   //Initialize the screen
 190:ttris.cpp     ****   init_screen();
 463               		.stabn	68,0,190,.LM45-.LFBB6
 464               	.LM45:
 465 0022 0E94 0000 		call _Z11init_screenv
 191:ttris.cpp     ****   blank_display();
 466               		.stabn	68,0,191,.LM46-.LFBB6
 467               	.LM46:
 468 0026 0E94 0000 		call _Z13blank_displayv
 469               	.LBB38:
 192:ttris.cpp     ****   //draw a test pattern
 193:ttris.cpp     ****   for(int y = 0; y < 48; y+=2)
 470               		.stabn	68,0,193,.LM47-.LFBB6
 471               	.LM47:
 472 002a C0E0      		ldi r28,0
 473 002c D0E0      		ldi r29,0
 474               	.L24:
 475               	.LBE38:
 476               	.LBE35:
 184:ttris.cpp     ****   //Give the AVR a bit to boot
 477               		.stabn	68,0,184,.LM48-.LFBB6
 478               	.LM48:
 479 002e 00E0      		ldi r16,0
 480 0030 10E0      		ldi r17,0
 481 0032 7E01      		movw r14,r28
 482 0034 2FEF      		ldi r18,-1
 483 0036 E21A      		sub r14,r18
 484 0038 F20A      		sbc r15,r18
 485               	.L25:
 486               	.LBB41:
 487               	.LBB40:
 488               	.LBB39:
 194:ttris.cpp     ****   {
 195:ttris.cpp     ****     for(int x = 0; x < 84; x = x + y + 1)
 196:ttris.cpp     ****     {
 197:ttris.cpp     ****       set_pixel(x, y, BLACK);
 489               		.stabn	68,0,197,.LM49-.LFBB6
 490               	.LM49:
 491 003a 41E0      		ldi r20,lo8(1)
 492 003c BE01      		movw r22,r28
 493 003e C801      		movw r24,r16
 494 0040 0E94 0000 		call _Z9set_pixeliib
 495 0044 0E0D      		add r16,r14
 496 0046 1F1D      		adc r17,r15
 195:ttris.cpp     ****     {
 497               		.stabn	68,0,195,.LM50-.LFBB6
 498               	.LM50:
 499 0048 0435      		cpi r16,84
 500 004a 1105      		cpc r17,__zero_reg__
 501 004c 04F0      		brlt .L25
 502               	.LBE39:
 193:ttris.cpp     ****   {
 503               		.stabn	68,0,193,.LM51-.LFBB6
 504               	.LM51:
 505 004e 2296      		adiw r28,2
 506 0050 C033      		cpi r28,48
 507 0052 D105      		cpc r29,__zero_reg__
 508 0054 01F4      		brne .L24
 509               	.LBE40:
 510               	.LBE41:
 198:ttris.cpp     ****     }
 199:ttris.cpp     ****   }
 200:ttris.cpp     ****   return(0);
 201:ttris.cpp     **** }
 511               		.stabn	68,0,201,.LM52-.LFBB6
 512               	.LM52:
 513 0056 80E0      		ldi r24,0
 514 0058 90E0      		ldi r25,0
 515               	/* epilogue start */
 516 005a DF91      		pop r29
 517 005c CF91      		pop r28
 518 005e 1F91      		pop r17
 519 0060 0F91      		pop r16
 520 0062 FF90      		pop r15
 521 0064 EF90      		pop r14
 522 0066 0895      		ret
 523               		.size	main, .-main
 524               		.stabs	"y:r(0,9)",64,0,193,28
 525               		.stabn	192,0,0,.LBB38-.LFBB6
 526               		.stabs	"x:r(0,9)",64,0,195,16
 527               		.stabn	192,0,0,.LBB39-.LFBB6
 528               		.stabn	224,0,0,.LBE39-.LFBB6
 529               		.stabn	224,0,0,.LBE38-.LFBB6
 530               		.stabs	"y:r(0,9)",64,0,193,28
 531               		.stabn	192,0,0,.LBB40-.LFBB6
 532               		.stabn	224,0,0,.LBE40-.LFBB6
 533               	.Lscope6:
 534               		.stabs	"",36,0,0,.Lscope6-.LFBB6
 535               		.stabd	78,0,0
 536               	.global	vbuff
 537               		.section .bss
 538               		.type	vbuff, @object
 539               		.size	vbuff, 504
 540               	vbuff:
 541 0000 0000 0000 		.zero	504
 541      0000 0000 
 541      0000 0000 
 541      0000 0000 
 541      0000 0000 
 542               		.stabs	"vbuff:G(0,90)=ar(0,91)=r(0,91);0;0177777;;0;5;(0,92)=ar(0,91);0;83;(0,89)",32,0,38,0
 543               		.text
 544               		.stabs	"",100,0,0,.Letext0
 545               	.Letext0:
 546               		.ident	"GCC: (GNU) 4.9.2"
 547               	.global __do_clear_bss
DEFINED SYMBOLS
                            *ABS*:0000000000000000 ttris.cpp
     /tmp/ccFlDbY3.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccFlDbY3.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccFlDbY3.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccFlDbY3.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccFlDbY3.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccFlDbY3.s:108    .text:0000000000000000 _Z15spi_init_masterv
     /tmp/ccFlDbY3.s:135    .text:000000000000000a _Z9send_bytehb
     /tmp/ccFlDbY3.s:178    .text:000000000000001c _Z11init_screenv
     /tmp/ccFlDbY3.s:236    .text:0000000000000052 _Z9set_pixeliib
     /tmp/ccFlDbY3.s:540    .bss:0000000000000000 vbuff
     /tmp/ccFlDbY3.s:384    .text:00000000000000e4 _Z13blank_displayv
     /tmp/ccFlDbY3.s:425    .text.startup:0000000000000000 main

UNDEFINED SYMBOLS
__divmodhi4
__do_clear_bss
