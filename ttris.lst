   1               		.file	"ttris.cpp"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.stabs	"/home/granthaack/Documents/ttris/",100,0,4,.Ltext0
   8               		.stabs	"ttris.cpp",100,0,4,.Ltext0
   9               		.text
  10               	.Ltext0:
  11               		.stabs	"gcc2_compiled.",60,0,0,0
  12               		.stabs	"__uint24:t(0,1)=@s24;r(0,1);0;077777777;",128,0,0,0
  13               		.stabs	"__int24:t(0,2)=@s24;r(0,2);040000000;037777777;",128,0,0,0
  14               		.stabs	"__builtin_va_list:t(0,3)=*(0,4)=(0,4)",128,0,0,0
  15               		.stabs	"complex long double:t(0,5)=R3;8;0;",128,0,0,0
  16               		.stabs	"complex double:t(0,6)=R3;8;0;",128,0,0,0
  17               		.stabs	"complex float:t(0,7)=R3;8;0;",128,0,0,0
  18               		.stabs	"complex int:t(0,8)=s4real:(0,9)=r(0,9);-32768;32767;,0,16;imag:(0,9),16,16;;",128,0,0,0
  19               		.stabs	"long long unsigned int:t(0,10)=@s64;r(0,10);0;01777777777777777777777;",128,0,0,0
  20               		.stabs	"long unsigned int:t(0,11)=@s32;r(0,11);0;037777777777;",128,0,0,0
  21               		.stabs	"unsigned int:t(0,12)=r(0,12);0;0177777;",128,0,0,0
  22               		.stabs	"unsigned char:t(0,13)=@s8;r(0,13);0;255;",128,0,0,0
  23               		.stabs	"long long int:t(0,14)=@s64;r(0,14);01000000000000000000000;0777777777777777777777;",128,0,
  24               		.stabs	"long int:t(0,15)=@s32;r(0,15);020000000000;017777777777;",128,0,0,0
  25               		.stabs	"int:t(0,9)",128,0,0,0
  26               		.stabs	"signed char:t(0,16)=@s8;r(0,16);-128;127;",128,0,0,0
  27               		.stabs	"char:t(0,17)=r(0,17);0;127;",128,0,0,0
  28               		.stabs	"signed:t(0,9)",128,0,0,0
  29               		.stabs	"unsigned long:t(0,11)",128,0,0,0
  30               		.stabs	"long long unsigned:t(0,10)",128,0,0,0
  31               		.stabs	"short int:t(0,18)=r(0,18);-32768;32767;",128,0,0,0
  32               		.stabs	"short unsigned int:t(0,19)=r(0,19);0;0177777;",128,0,0,0
  33               		.stabs	"unsigned short:t(0,19)",128,0,0,0
  34               		.stabs	"float:t(0,20)=r(0,9);4;0;",128,0,0,0
  35               		.stabs	"double:t(0,21)=r(0,9);4;0;",128,0,0,0
  36               		.stabs	"long double:t(0,22)=r(0,9);4;0;",128,0,0,0
  37               		.stabs	"short _Fract:t(0,23)=r(0,9);1;0;",128,0,0,0
  38               		.stabs	"long _Fract:t(0,24)=r(0,9);4;0;",128,0,0,0
  39               		.stabs	"long long _Fract:t(0,25)=r(0,9);8;0;",128,0,0,0
  40               		.stabs	"unsigned short _Fract:t(0,26)=r(0,9);1;0;",128,0,0,0
  41               		.stabs	"unsigned _Fract:t(0,27)=r(0,9);2;0;",128,0,0,0
  42               		.stabs	"unsigned long _Fract:t(0,28)=r(0,9);4;0;",128,0,0,0
  43               		.stabs	"unsigned long long _Fract:t(0,29)=r(0,9);8;0;",128,0,0,0
  44               		.stabs	"_Sat short _Fract:t(0,30)=r(0,9);1;0;",128,0,0,0
  45               		.stabs	"_Sat _Fract:t(0,31)=r(0,9);2;0;",128,0,0,0
  46               		.stabs	"_Sat long _Fract:t(0,32)=r(0,9);4;0;",128,0,0,0
  47               		.stabs	"_Sat long long _Fract:t(0,33)=r(0,9);8;0;",128,0,0,0
  48               		.stabs	"_Sat unsigned short _Fract:t(0,34)=r(0,9);1;0;",128,0,0,0
  49               		.stabs	"_Sat unsigned _Fract:t(0,35)=r(0,9);2;0;",128,0,0,0
  50               		.stabs	"_Sat unsigned long _Fract:t(0,36)=r(0,9);4;0;",128,0,0,0
  51               		.stabs	"_Sat unsigned long long _Fract:t(0,37)=r(0,9);8;0;",128,0,0,0
  52               		.stabs	"short _Accum:t(0,38)=r(0,9);2;0;",128,0,0,0
  53               		.stabs	"long _Accum:t(0,39)=r(0,9);8;0;",128,0,0,0
  54               		.stabs	"long long _Accum:t(0,40)=r(0,9);8;0;",128,0,0,0
  55               		.stabs	"unsigned short _Accum:t(0,41)=r(0,9);2;0;",128,0,0,0
  56               		.stabs	"unsigned _Accum:t(0,42)=r(0,9);4;0;",128,0,0,0
  57               		.stabs	"unsigned long _Accum:t(0,43)=r(0,9);8;0;",128,0,0,0
  58               		.stabs	"unsigned long long _Accum:t(0,44)=r(0,9);8;0;",128,0,0,0
  59               		.stabs	"_Sat short _Accum:t(0,45)=r(0,9);2;0;",128,0,0,0
  60               		.stabs	"_Sat _Accum:t(0,46)=r(0,9);4;0;",128,0,0,0
  61               		.stabs	"_Sat long _Accum:t(0,47)=r(0,9);8;0;",128,0,0,0
  62               		.stabs	"_Sat long long _Accum:t(0,48)=r(0,9);8;0;",128,0,0,0
  63               		.stabs	"_Sat unsigned short _Accum:t(0,49)=r(0,9);2;0;",128,0,0,0
  64               		.stabs	"_Sat unsigned _Accum:t(0,50)=r(0,9);4;0;",128,0,0,0
  65               		.stabs	"_Sat unsigned long _Accum:t(0,51)=r(0,9);8;0;",128,0,0,0
  66               		.stabs	"_Sat unsigned long long _Accum:t(0,52)=r(0,9);8;0;",128,0,0,0
  67               		.stabs	"void:t(0,4)",128,0,0,0
  68               		.stabs	"wchar_t:t(0,53)=r(0,53);-32768;32767;",128,0,0,0
  69               		.stabs	"bool:t(0,54)=@s8;-16;",128,0,0,0
  70               		.stabs	"__vtbl_ptr_type:t(0,55)=*(0,56)=f(0,9)",128,0,0,0
  71               		.stabs	"decltype(nullptr):t(0,57)=(0,57)",128,0,0,0
  72               		.stabs	"int8_t:t(0,58)=(0,16)",128,0,121,0
  73               		.stabs	"uint8_t:t(0,59)=(0,13)",128,0,122,0
  74               		.stabs	"int16_t:t(0,60)=(0,9)",128,0,123,0
  75               		.stabs	"uint16_t:t(0,61)=(0,12)",128,0,124,0
  76               		.stabs	"int32_t:t(0,62)=(0,15)",128,0,125,0
  77               		.stabs	"uint32_t:t(0,63)=(0,11)",128,0,126,0
  78               		.stabs	"int64_t:t(0,64)=(0,14)",128,0,128,0
  79               		.stabs	"uint64_t:t(0,65)=(0,10)",128,0,129,0
  80               		.stabs	"intptr_t:t(0,66)=(0,60)",128,0,142,0
  81               		.stabs	"uintptr_t:t(0,67)=(0,61)",128,0,147,0
  82               		.stabs	"int_least8_t:t(0,68)=(0,58)",128,0,159,0
  83               		.stabs	"uint_least8_t:t(0,69)=(0,59)",128,0,164,0
  84               		.stabs	"int_least16_t:t(0,70)=(0,60)",128,0,169,0
  85               		.stabs	"uint_least16_t:t(0,71)=(0,61)",128,0,174,0
  86               		.stabs	"int_least32_t:t(0,72)=(0,62)",128,0,179,0
  87               		.stabs	"uint_least32_t:t(0,73)=(0,63)",128,0,184,0
  88               		.stabs	"int_least64_t:t(0,74)=(0,64)",128,0,192,0
  89               		.stabs	"uint_least64_t:t(0,75)=(0,65)",128,0,199,0
  90               		.stabs	"int_fast8_t:t(0,76)=(0,58)",128,0,213,0
  91               		.stabs	"uint_fast8_t:t(0,77)=(0,59)",128,0,218,0
  92               		.stabs	"int_fast16_t:t(0,78)=(0,60)",128,0,223,0
  93               		.stabs	"uint_fast16_t:t(0,79)=(0,61)",128,0,228,0
  94               		.stabs	"int_fast32_t:t(0,80)=(0,62)",128,0,233,0
  95               		.stabs	"uint_fast32_t:t(0,81)=(0,63)",128,0,238,0
  96               		.stabs	"int_fast64_t:t(0,82)=(0,64)",128,0,246,0
  97               		.stabs	"uint_fast64_t:t(0,83)=(0,65)",128,0,253,0
  98               		.stabs	"intmax_t:t(0,84)=(0,64)",128,0,273,0
  99               		.stabs	"uintmax_t:t(0,85)=(0,65)",128,0,278,0
 100               		.stabs	"int_farptr_t:t(0,86)=(0,62)",128,0,77,0
 101               		.stabs	"uint_farptr_t:t(0,87)=(0,63)",128,0,81,0
 102               		.stabs	"._0:Tt(0,88)=s3low:(0,13),0,8;high:(0,13),8,8;extended:(0,13),16,8;;",128,0,240,0
 103               		.stabs	"__fuse_t:t(0,88)",128,0,244,0
 104               		.stabs	"byte:t(0,89)=(0,13)",128,0,7,0
 105               		.stabs	"sprite:Tt(0,90)=s12x_map:(0,9),0,16;y_map:(0,9),16,16;x_pos:(0,9),32,16;y_pos:(0,9),48,16;
 106               		.stabs	"string_sprite:Tt(0,91)=s6x_pos:(0,9),0,16;y_pos:(0,9),16,16;str:(0,92)=*(0,17),32,16;;",12
 107               		.stabs	"_Z15spi_init_masterv:F(0,4)",36,0,70,_Z15spi_init_masterv
 108               	.global	_Z15spi_init_masterv
 109               		.type	_Z15spi_init_masterv, @function
 110               	_Z15spi_init_masterv:
 111               		.stabd	46,0,0
   1:ttris.cpp     **** #define F_CPU  16000000UL
   2:ttris.cpp     **** 
   3:ttris.cpp     **** #include <avr/io.h>
   4:ttris.cpp     **** #include <util/delay.h>
   5:ttris.cpp     **** #include <avr/interrupt.h>
   6:ttris.cpp     **** 
   7:ttris.cpp     **** typedef unsigned char byte;
   8:ttris.cpp     **** 
   9:ttris.cpp     **** #define HIGH 1
  10:ttris.cpp     **** #define LOW 0
  11:ttris.cpp     **** 
  12:ttris.cpp     **** #define BLACK 1
  13:ttris.cpp     **** #define WHITE 0
  14:ttris.cpp     **** 
  15:ttris.cpp     **** #define DATA 1
  16:ttris.cpp     **** #define COMM 0
  17:ttris.cpp     **** 
  18:ttris.cpp     **** //Define the SPI Pins to communicate with the screen
  19:ttris.cpp     **** //Define the data direction registers
  20:ttris.cpp     **** #define DDR_SPI         DDRB
  21:ttris.cpp     **** #define DD_SCK          DDB5
  22:ttris.cpp     **** #define DD_MISO         DDB4
  23:ttris.cpp     **** #define DD_MOSI         DDB3
  24:ttris.cpp     **** #define DD_SS           DDB2
  25:ttris.cpp     **** #define DD_DC           DDB1
  26:ttris.cpp     **** #define DD_RST          DDB0
  27:ttris.cpp     **** 
  28:ttris.cpp     **** //Define the port registers
  29:ttris.cpp     **** #define PORT_SPI        PORTB
  30:ttris.cpp     **** #define PORT_SCK        (1 << PB5) //yellow
  31:ttris.cpp     **** #define PORT_MISO       (1 << PB4) //green (unused)
  32:ttris.cpp     **** #define PORT_MOSI       (1 << PB3) //white
  33:ttris.cpp     **** #define PORT_SS         (1 << PB2) //orange
  34:ttris.cpp     **** #define PORT_DC         (1 << PB1) //blue
  35:ttris.cpp     **** #define PORT_RST        (1 << PB0) //green
  36:ttris.cpp     **** 
  37:ttris.cpp     **** struct sprite
  38:ttris.cpp     **** {
  39:ttris.cpp     ****   //The x and y coordinates of where the sprite appears on the spritemap
  40:ttris.cpp     ****   int x_map;
  41:ttris.cpp     ****   int y_map;
  42:ttris.cpp     ****   //The x and y coordinates of where the sprite will be drawn on the screen
  43:ttris.cpp     ****   int x_pos;
  44:ttris.cpp     ****   int y_pos;
  45:ttris.cpp     ****   //The width and height of the sprite
  46:ttris.cpp     ****   int wdth;
  47:ttris.cpp     ****   int hght;
  48:ttris.cpp     **** };
  49:ttris.cpp     **** 
  50:ttris.cpp     **** struct string_sprite
  51:ttris.cpp     **** {
  52:ttris.cpp     ****   int x_pos;
  53:ttris.cpp     ****   int y_pos;
  54:ttris.cpp     ****   char* str;
  55:ttris.cpp     **** };
  56:ttris.cpp     **** 
  57:ttris.cpp     **** //Init the video buffer
  58:ttris.cpp     **** byte fbuff[6][84] = {
  59:ttris.cpp     **** 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0
  60:ttris.cpp     **** 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0
  61:ttris.cpp     **** 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0
  62:ttris.cpp     **** 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0
  63:ttris.cpp     **** 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0
  64:ttris.cpp     **** 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0
  65:ttris.cpp     **** };
  66:ttris.cpp     **** 
  67:ttris.cpp     **** byte spritemap[2][84] = {0x00, 0x6e, 0x8a, 0xea, 0x8a, 0xee, 0x00, 0x64, 0x84, 0xe4, 0x84, 0x84, 0x
  68:ttris.cpp     **** 
  69:ttris.cpp     **** // Initialize SPI Master Device (with SPI interrupt)
  70:ttris.cpp     **** void spi_init_master (void)
  71:ttris.cpp     **** {
 112               		.stabn	68,0,71,.LM0-.LFBB1
 113               	.LM0:
 114               	.LFBB1:
 115               	/* prologue: function */
 116               	/* frame size = 0 */
 117               	/* stack size = 0 */
 118               	.L__stack_usage = 0
  72:ttris.cpp     ****     // Set MOSI, SCK, SS, DC, and RST as Output
  73:ttris.cpp     ****     DDR_SPI=(1<<DD_MOSI)|(1<<DD_SCK)|(1<<DD_SS)|(1<<DD_DC)|(1<<DD_RST);
 119               		.stabn	68,0,73,.LM1-.LFBB1
 120               	.LM1:
 121 0000 8FE2      		ldi r24,lo8(47)
 122 0002 84B9      		out 0x4,r24
  74:ttris.cpp     **** 
  75:ttris.cpp     ****     // Enable SPI, Set as Master
  76:ttris.cpp     ****     // Prescaler: Fosc/16, Enable Interrupts
  77:ttris.cpp     ****     //The MOSI, SCK pins are as per ATMega8
  78:ttris.cpp     ****     SPCR=(1<<SPE)|(1<<MSTR)|(1<<SPR0);
 123               		.stabn	68,0,78,.LM2-.LFBB1
 124               	.LM2:
 125 0004 81E5      		ldi r24,lo8(81)
 126 0006 8CBD      		out 0x2c,r24
 127 0008 0895      		ret
 128               		.size	_Z15spi_init_masterv, .-_Z15spi_init_masterv
 129               	.Lscope1:
 130               		.stabs	"",36,0,0,.Lscope1-.LFBB1
 131               		.stabd	78,0,0
 132               		.stabs	"_Z9send_bytehb:F(0,4)",36,0,82,_Z9send_bytehb
 133               		.stabs	"data:P(0,89)",64,0,82,24
 134               		.stabs	"dc:P(0,54)",64,0,82,22
 135               	.global	_Z9send_bytehb
 136               		.type	_Z9send_bytehb, @function
 137               	_Z9send_bytehb:
 138               		.stabd	46,0,0
  79:ttris.cpp     **** }
  80:ttris.cpp     **** 
  81:ttris.cpp     **** //Function to send and receive data for both master and slave
  82:ttris.cpp     **** void send_byte(byte data, bool dc)
  83:ttris.cpp     **** {
 139               		.stabn	68,0,83,.LM3-.LFBB2
 140               	.LM3:
 141               	.LFBB2:
 142               	/* prologue: function */
 143               	/* frame size = 0 */
 144               	/* stack size = 0 */
 145               	.L__stack_usage = 0
  84:ttris.cpp     ****     // Load data into the buffer
  85:ttris.cpp     ****     SPDR = data;
 146               		.stabn	68,0,85,.LM4-.LFBB2
 147               	.LM4:
 148 000a 8EBD      		out 0x2e,r24
  86:ttris.cpp     **** 
  87:ttris.cpp     ****     //If DC is high, pull the pin high
  88:ttris.cpp     ****     if(dc)
 149               		.stabn	68,0,88,.LM5-.LFBB2
 150               	.LM5:
 151 000c 6111      		cpse r22,__zero_reg__
  89:ttris.cpp     ****     {
  90:ttris.cpp     ****       PORT_SPI |= (PORT_DC);
 152               		.stabn	68,0,90,.LM6-.LFBB2
 153               	.LM6:
 154 000e 299A      		sbi 0x5,1
 155               	.L4:
  91:ttris.cpp     ****     }
  92:ttris.cpp     **** 
  93:ttris.cpp     ****     //Wait until transmission complete
  94:ttris.cpp     ****     while(!(SPSR & (1<<SPIF)));
 156               		.stabn	68,0,94,.LM7-.LFBB2
 157               	.LM7:
 158 0010 0DB4      		in __tmp_reg__,0x2d
 159 0012 07FE      		sbrs __tmp_reg__,7
 160 0014 00C0      		rjmp .L4
  95:ttris.cpp     **** 
  96:ttris.cpp     ****     //Pull DC low again if it was set high
  97:ttris.cpp     ****     if(dc)
 161               		.stabn	68,0,97,.LM8-.LFBB2
 162               	.LM8:
 163 0016 6111      		cpse r22,__zero_reg__
 164               	.LBB12:
 165               	.LBB13:
  98:ttris.cpp     ****     {
  99:ttris.cpp     ****       PORT_SPI &= ~(PORT_DC);
 166               		.stabn	68,0,99,.LM9-.LFBB2
 167               	.LM9:
 168 0018 2998      		cbi 0x5,1
 169               	.L2:
 170 001a 0895      		ret
 171               	.LBE13:
 172               	.LBE12:
 173               		.size	_Z9send_bytehb, .-_Z9send_bytehb
 174               	.Lscope2:
 175               		.stabs	"",36,0,0,.Lscope2-.LFBB2
 176               		.stabd	78,0,0
 177               		.stabs	"_Z11init_screenv:F(0,4)",36,0,104,_Z11init_screenv
 178               	.global	_Z11init_screenv
 179               		.type	_Z11init_screenv, @function
 180               	_Z11init_screenv:
 181               		.stabd	46,0,0
 100:ttris.cpp     ****     }
 101:ttris.cpp     ****     return;
 102:ttris.cpp     **** }
 103:ttris.cpp     **** 
 104:ttris.cpp     **** void init_screen(void)
 105:ttris.cpp     **** {
 182               		.stabn	68,0,105,.LM10-.LFBB3
 183               	.LM10:
 184               	.LFBB3:
 185               	/* prologue: function */
 186               	/* frame size = 0 */
 187               	/* stack size = 0 */
 188               	.L__stack_usage = 0
 106:ttris.cpp     ****   //Toggle the reset pin then set it high
 107:ttris.cpp     ****   PORT_SPI |= (PORT_RST);
 189               		.stabn	68,0,107,.LM11-.LFBB3
 190               	.LM11:
 191 001c 289A      		sbi 0x5,0
 108:ttris.cpp     ****   PORT_SPI &= ~(PORT_RST);
 192               		.stabn	68,0,108,.LM12-.LFBB3
 193               	.LM12:
 194 001e 2898      		cbi 0x5,0
 109:ttris.cpp     ****   PORT_SPI |= (PORT_RST);
 195               		.stabn	68,0,109,.LM13-.LFBB3
 196               	.LM13:
 197 0020 289A      		sbi 0x5,0
 110:ttris.cpp     **** 
 111:ttris.cpp     ****   //send a byte to init function set
 112:ttris.cpp     ****   send_byte(0b00100001, COMM);
 198               		.stabn	68,0,112,.LM14-.LFBB3
 199               	.LM14:
 200 0022 60E0      		ldi r22,0
 201 0024 81E2      		ldi r24,lo8(33)
 202 0026 0E94 0000 		call _Z9send_bytehb
 113:ttris.cpp     ****   //send byte to init Vop
 114:ttris.cpp     ****   send_byte(0b10010000, COMM);
 203               		.stabn	68,0,114,.LM15-.LFBB3
 204               	.LM15:
 205 002a 60E0      		ldi r22,0
 206 002c 80E9      		ldi r24,lo8(-112)
 207 002e 0E94 0000 		call _Z9send_bytehb
 115:ttris.cpp     ****   //send byte to select normal instruction set
 116:ttris.cpp     ****   send_byte(0b00100000, COMM);
 208               		.stabn	68,0,116,.LM16-.LFBB3
 209               	.LM16:
 210 0032 60E0      		ldi r22,0
 211 0034 80E2      		ldi r24,lo8(32)
 212 0036 0E94 0000 		call _Z9send_bytehb
 117:ttris.cpp     ****   //send byte to set screen to normal mode
 118:ttris.cpp     ****   send_byte(0b00001100, COMM);
 213               		.stabn	68,0,118,.LM17-.LFBB3
 214               	.LM17:
 215 003a 60E0      		ldi r22,0
 216 003c 8CE0      		ldi r24,lo8(12)
 217 003e 0E94 0000 		call _Z9send_bytehb
 119:ttris.cpp     ****   //set x DDRAM address to 0
 120:ttris.cpp     ****   send_byte(0b10000000, COMM);
 218               		.stabn	68,0,120,.LM18-.LFBB3
 219               	.LM18:
 220 0042 60E0      		ldi r22,0
 221 0044 80E8      		ldi r24,lo8(-128)
 222 0046 0E94 0000 		call _Z9send_bytehb
 121:ttris.cpp     ****   //set y DDRAM address to 0
 122:ttris.cpp     ****   send_byte(0b01000000, COMM);
 223               		.stabn	68,0,122,.LM19-.LFBB3
 224               	.LM19:
 225 004a 60E0      		ldi r22,0
 226 004c 80E4      		ldi r24,lo8(64)
 227 004e 0C94 0000 		jmp _Z9send_bytehb
 228               		.size	_Z11init_screenv, .-_Z11init_screenv
 229               	.Lscope3:
 230               		.stabs	"",36,0,0,.Lscope3-.LFBB3
 231               		.stabd	78,0,0
 232               		.stabs	"_Z9set_pixeliib:F(0,4)",36,0,128,_Z9set_pixeliib
 233               		.stabs	"x:P(0,9)",64,0,128,24
 234               		.stabs	"y:P(0,9)",64,0,128,22
 235               		.stabs	"color:P(0,54)",64,0,128,20
 236               	.global	_Z9set_pixeliib
 237               		.type	_Z9set_pixeliib, @function
 238               	_Z9set_pixeliib:
 239               		.stabd	46,0,0
 123:ttris.cpp     **** }
 124:ttris.cpp     **** 
 125:ttris.cpp     **** //This function sets pixels in the display. Instead of changing the frame
 126:ttris.cpp     **** //buffer and sending the whole buffer to the screen, this function only changes
 127:ttris.cpp     **** //the necessary pixels on the display.
 128:ttris.cpp     **** void set_pixel(int x, int y, bool color)
 129:ttris.cpp     **** {
 240               		.stabn	68,0,129,.LM20-.LFBB4
 241               	.LM20:
 242               	.LFBB4:
 243 0052 0F93      		push r16
 244 0054 1F93      		push r17
 245 0056 CF93      		push r28
 246 0058 DF93      		push r29
 247               	/* prologue: function */
 248               	/* frame size = 0 */
 249               	/* stack size = 4 */
 250               	.L__stack_usage = 4
 251               	.LBB21:
 130:ttris.cpp     ****   //if out of bounds
 131:ttris.cpp     ****   if(x > 83 || y > 47)
 252               		.stabn	68,0,131,.LM21-.LFBB4
 253               	.LM21:
 254 005a 8435      		cpi r24,84
 255 005c 9105      		cpc r25,__zero_reg__
 256 005e 04F4      		brge .L15
 257               		.stabn	68,0,131,.LM22-.LFBB4
 258               	.LM22:
 259 0060 6033      		cpi r22,48
 260 0062 7105      		cpc r23,__zero_reg__
 261 0064 04F4      		brge .L15
 262               	.LBE21:
 263               	.LBB22:
 264               	.LBB23:
 132:ttris.cpp     ****   {
 133:ttris.cpp     ****     return;
 134:ttris.cpp     ****   }
 135:ttris.cpp     **** 
 136:ttris.cpp     ****   //Which byte to manipulate
 137:ttris.cpp     ****   int i = y/8;
 265               		.stabn	68,0,137,.LM23-.LFBB4
 266               	.LM23:
 267 0066 FB01      		movw r30,r22
 268 0068 77FD      		sbrc r23,7
 269 006a 3796      		adiw r30,7
 270               	.L17:
 271 006c 9C01      		movw r18,r24
 272 006e 83E0      		ldi r24,3
 273               		1:
 274 0070 F595      		asr r31
 275 0072 E795      		ror r30
 276 0074 8A95      		dec r24
 277 0076 01F4      		brne 1b
 138:ttris.cpp     ****   //Which bit in the byte to manipulate
 139:ttris.cpp     ****   int pos = y%8;
 278               		.stabn	68,0,139,.LM24-.LFBB4
 279               	.LM24:
 280 0078 CB01      		movw r24,r22
 281 007a 68E0      		ldi r22,lo8(8)
 282 007c 70E0      		ldi r23,0
 283 007e 0E94 0000 		call __divmodhi4
 140:ttris.cpp     ****   //Positioning the byte for masking or oring
 141:ttris.cpp     ****   byte flag = 0x01;
 142:ttris.cpp     ****   flag = flag << pos;
 284               		.stabn	68,0,142,.LM25-.LFBB4
 285               	.LM25:
 286 0082 61E0      		ldi r22,lo8(1)
 287 0084 70E0      		ldi r23,0
 288 0086 00C0      		rjmp 2f
 289               		1:
 290 0088 660F      		lsl r22
 291               		2:
 292 008a 8A95      		dec r24
 293 008c 02F4      		brpl 1b
 294 008e CF01      		movw r24,r30
 295 0090 8064      		ori r24,64
 296 0092 8901      		movw r16,r18
 297 0094 0068      		ori r16,128
 298               	.LBB24:
 299               	.LBB25:
 143:ttris.cpp     **** 
 144:ttris.cpp     ****   //If setting it black, bitwise or
 145:ttris.cpp     ****   if(color)
 146:ttris.cpp     ****   {
 147:ttris.cpp     ****     //write the changes to the internal fbuff
 148:ttris.cpp     ****     fbuff[i][x] = fbuff[i][x] | flag;
 300               		.stabn	68,0,148,.LM26-.LFBB4
 301               	.LM26:
 302 0096 94E5      		ldi r25,lo8(84)
 303 0098 9E9F      		mul r25,r30
 304 009a E001      		movw r28,r0
 305 009c 9F9F      		mul r25,r31
 306 009e D00D      		add r29,r0
 307 00a0 1124      		clr __zero_reg__
 308 00a2 C20F      		add r28,r18
 309 00a4 D31F      		adc r29,r19
 310 00a6 C050      		subi r28,lo8(-(fbuff))
 311 00a8 D040      		sbci r29,hi8(-(fbuff))
 312               	.LBE25:
 145:ttris.cpp     ****   {
 313               		.stabn	68,0,145,.LM27-.LFBB4
 314               	.LM27:
 315 00aa 4423      		tst r20
 316 00ac 01F0      		breq .L18
 317               	.LBB26:
 318               		.stabn	68,0,148,.LM28-.LFBB4
 319               	.LM28:
 320 00ae 9881      		ld r25,Y
 321 00b0 692B      		or r22,r25
 322 00b2 00C0      		rjmp .L19
 323               	.L18:
 324               	.LBE26:
 325               	.LBB27:
 149:ttris.cpp     **** 
 150:ttris.cpp     ****     //update the y address
 151:ttris.cpp     ****     int sendy = i | 0b01000000;
 152:ttris.cpp     ****     send_byte(sendy, COMM);
 153:ttris.cpp     ****     //update the x address
 154:ttris.cpp     ****     int sendx = x | 0b10000000;
 155:ttris.cpp     ****     send_byte(sendx, COMM);
 156:ttris.cpp     **** 
 157:ttris.cpp     ****     //Send the updated byte to the screen
 158:ttris.cpp     ****     send_byte(fbuff[i][x], DATA);
 159:ttris.cpp     **** 
 160:ttris.cpp     ****   }
 161:ttris.cpp     **** 
 162:ttris.cpp     ****   //If setting it white, mask and bitwise and
 163:ttris.cpp     ****   else
 164:ttris.cpp     ****   {
 165:ttris.cpp     ****     flag = ~flag;
 326               		.stabn	68,0,165,.LM29-.LFBB4
 327               	.LM29:
 328 00b4 6095      		com r22
 166:ttris.cpp     ****     fbuff[i][x] = fbuff[i][x] & flag;
 329               		.stabn	68,0,166,.LM30-.LFBB4
 330               	.LM30:
 331 00b6 9881      		ld r25,Y
 332 00b8 6923      		and r22,r25
 333               	.L19:
 334 00ba 6883      		st Y,r22
 167:ttris.cpp     **** 
 168:ttris.cpp     ****     //update the y address
 169:ttris.cpp     ****     int sendy = i | 0b01000000;
 170:ttris.cpp     ****     send_byte(sendy, COMM);
 335               		.stabn	68,0,170,.LM31-.LFBB4
 336               	.LM31:
 337 00bc 60E0      		ldi r22,0
 338 00be 0E94 0000 		call _Z9send_bytehb
 171:ttris.cpp     ****     //update the x address
 172:ttris.cpp     ****     int sendx = x | 0b10000000;
 173:ttris.cpp     ****     send_byte(sendx, COMM);
 339               		.stabn	68,0,173,.LM32-.LFBB4
 340               	.LM32:
 341 00c2 60E0      		ldi r22,0
 342 00c4 802F      		mov r24,r16
 343 00c6 0E94 0000 		call _Z9send_bytehb
 174:ttris.cpp     **** 
 175:ttris.cpp     ****     //Send the updated byte to the screen
 176:ttris.cpp     ****     send_byte(fbuff[i][x], DATA);
 344               		.stabn	68,0,176,.LM33-.LFBB4
 345               	.LM33:
 346 00ca 61E0      		ldi r22,lo8(1)
 347 00cc 8881      		ld r24,Y
 348               	/* epilogue start */
 349               	.LBE27:
 350               	.LBE24:
 351               	.LBE23:
 352               	.LBE22:
 177:ttris.cpp     ****   }
 178:ttris.cpp     **** }
 353               		.stabn	68,0,178,.LM34-.LFBB4
 354               	.LM34:
 355 00ce DF91      		pop r29
 356 00d0 CF91      		pop r28
 357 00d2 1F91      		pop r17
 358 00d4 0F91      		pop r16
 359               	.LBB31:
 360               	.LBB30:
 361               	.LBB29:
 362               	.LBB28:
 176:ttris.cpp     ****   }
 363               		.stabn	68,0,176,.LM35-.LFBB4
 364               	.LM35:
 365 00d6 0C94 0000 		jmp _Z9send_bytehb
 366               	.L15:
 367               	/* epilogue start */
 368               	.LBE28:
 369               	.LBE29:
 370               	.LBE30:
 371               	.LBE31:
 372               		.stabn	68,0,178,.LM36-.LFBB4
 373               	.LM36:
 374 00da DF91      		pop r29
 375 00dc CF91      		pop r28
 376 00de 1F91      		pop r17
 377 00e0 0F91      		pop r16
 378 00e2 0895      		ret
 379               		.size	_Z9set_pixeliib, .-_Z9set_pixeliib
 380               	.Lscope4:
 381               		.stabs	"",36,0,0,.Lscope4-.LFBB4
 382               		.stabd	78,0,0
 383               		.stabs	"_Z13blank_displayv:F(0,4)",36,0,180,_Z13blank_displayv
 384               	.global	_Z13blank_displayv
 385               		.type	_Z13blank_displayv, @function
 386               	_Z13blank_displayv:
 387               		.stabd	46,0,0
 179:ttris.cpp     **** 
 180:ttris.cpp     **** void blank_display()
 181:ttris.cpp     **** {
 388               		.stabn	68,0,181,.LM37-.LFBB5
 389               	.LM37:
 390               	.LFBB5:
 391 00e4 CF93      		push r28
 392 00e6 DF93      		push r29
 393               	/* prologue: function */
 394               	/* frame size = 0 */
 395               	/* stack size = 2 */
 396               	.L__stack_usage = 2
 397               		.stabn	68,0,181,.LM38-.LFBB5
 398               	.LM38:
 399 00e8 C8EF      		ldi r28,lo8(-8)
 400 00ea D1E0      		ldi r29,lo8(1)
 401               	.L21:
 402               	.LBB32:
 182:ttris.cpp     ****   for(int i = 0; i < 504; i++)
 183:ttris.cpp     ****   {
 184:ttris.cpp     ****     send_byte(0, DATA);
 403               		.stabn	68,0,184,.LM39-.LFBB5
 404               	.LM39:
 405 00ec 61E0      		ldi r22,lo8(1)
 406 00ee 80E0      		ldi r24,0
 407 00f0 0E94 0000 		call _Z9send_bytehb
 408 00f4 2197      		sbiw r28,1
 182:ttris.cpp     ****   for(int i = 0; i < 504; i++)
 409               		.stabn	68,0,182,.LM40-.LFBB5
 410               	.LM40:
 411 00f6 01F4      		brne .L21
 412               	/* epilogue start */
 413               	.LBE32:
 185:ttris.cpp     ****   }
 186:ttris.cpp     **** }
 414               		.stabn	68,0,186,.LM41-.LFBB5
 415               	.LM41:
 416 00f8 DF91      		pop r29
 417 00fa CF91      		pop r28
 418 00fc 0895      		ret
 419               		.size	_Z13blank_displayv, .-_Z13blank_displayv
 420               	.Lscope5:
 421               		.stabs	"",36,0,0,.Lscope5-.LFBB5
 422               		.stabd	78,0,0
 423               		.stabs	"_Z10read_pixeliiPA84_h:F(0,54)",36,0,189,_Z10read_pixeliiPA84_h
 424               		.stabs	"x:P(0,9)",64,0,189,28
 425               		.stabs	"arr:P(0,93)=*(0,94)=ar(0,95)=r(0,95);0;0177777;;0;83;(0,89)",64,0,189,14
 426               	.global	_Z10read_pixeliiPA84_h
 427               		.type	_Z10read_pixeliiPA84_h, @function
 428               	_Z10read_pixeliiPA84_h:
 429               		.stabd	46,0,0
 187:ttris.cpp     **** 
 188:ttris.cpp     **** //This function can read pixels in the spritemap or fbuff
 189:ttris.cpp     **** bool read_pixel(int x, int y, byte arr[][84])
 190:ttris.cpp     **** {
 430               		.stabn	68,0,190,.LM42-.LFBB6
 431               	.LM42:
 432               	.LFBB6:
 433 00fe EF92      		push r14
 434 0100 FF92      		push r15
 435 0102 0F93      		push r16
 436 0104 1F93      		push r17
 437 0106 CF93      		push r28
 438 0108 DF93      		push r29
 439               	/* prologue: function */
 440               	/* frame size = 0 */
 441               	/* stack size = 6 */
 442               	.L__stack_usage = 6
 443 010a EC01      		movw r28,r24
 444 010c 8B01      		movw r16,r22
 445 010e 7A01      		movw r14,r20
 446               	.LBB33:
 191:ttris.cpp     ****   //Which byte to check
 192:ttris.cpp     ****   int i = y/8;
 193:ttris.cpp     ****   //Which bit in the byte to check
 194:ttris.cpp     ****   int pos = y%8;
 447               		.stabn	68,0,194,.LM43-.LFBB6
 448               	.LM43:
 449 0110 CB01      		movw r24,r22
 450 0112 68E0      		ldi r22,lo8(8)
 451 0114 70E0      		ldi r23,0
 452 0116 0E94 0000 		call __divmodhi4
 195:ttris.cpp     ****   //Positioning the bit for checking
 196:ttris.cpp     ****   byte flag = 0x01;
 197:ttris.cpp     ****   flag = flag << pos;
 453               		.stabn	68,0,197,.LM44-.LFBB6
 454               	.LM44:
 455 011a E1E0      		ldi r30,lo8(1)
 456 011c F0E0      		ldi r31,0
 457 011e 00C0      		rjmp 2f
 458               		1:
 459 0120 EE0F      		lsl r30
 460               		2:
 461 0122 8A95      		dec r24
 462 0124 02F4      		brpl 1b
 192:ttris.cpp     ****   //Which bit in the byte to check
 463               		.stabn	68,0,192,.LM45-.LFBB6
 464               	.LM45:
 465 0126 9801      		movw r18,r16
 466 0128 17FF      		sbrs r17,7
 467 012a 00C0      		rjmp .L24
 468 012c 295F      		subi r18,-7
 469 012e 3F4F      		sbci r19,-1
 470               	.L24:
 471 0130 83E0      		ldi r24,3
 472               		1:
 473 0132 3595      		asr r19
 474 0134 2795      		ror r18
 475 0136 8A95      		dec r24
 476 0138 01F4      		brne 1b
 198:ttris.cpp     **** 
 199:ttris.cpp     ****   //If there is a bit at that position, this will return true (pixel is black).
 200:ttris.cpp     ****   //If there is no bit, this will return false (pixel is white)
 201:ttris.cpp     ****   return arr[i][x] & flag;
 477               		.stabn	68,0,201,.LM46-.LFBB6
 478               	.LM46:
 479 013a 44E5      		ldi r20,lo8(84)
 480 013c 429F      		mul r20,r18
 481 013e C001      		movw r24,r0
 482 0140 439F      		mul r20,r19
 483 0142 900D      		add r25,r0
 484 0144 1124      		clr __zero_reg__
 485 0146 A701      		movw r20,r14
 486 0148 480F      		add r20,r24
 487 014a 591F      		adc r21,r25
 488 014c C40F      		add r28,r20
 489 014e D51F      		adc r29,r21
 490 0150 8881      		ld r24,Y
 491 0152 E823      		and r30,r24
 492 0154 81E0      		ldi r24,lo8(1)
 493 0156 01F4      		brne .L25
 494 0158 80E0      		ldi r24,0
 495               	.L25:
 496               	/* epilogue start */
 497               	.LBE33:
 202:ttris.cpp     **** }
 498               		.stabn	68,0,202,.LM47-.LFBB6
 499               	.LM47:
 500 015a DF91      		pop r29
 501 015c CF91      		pop r28
 502 015e 1F91      		pop r17
 503 0160 0F91      		pop r16
 504 0162 FF90      		pop r15
 505 0164 EF90      		pop r14
 506 0166 0895      		ret
 507               		.size	_Z10read_pixeliiPA84_h, .-_Z10read_pixeliiPA84_h
 508               	.Lscope6:
 509               		.stabs	"",36,0,0,.Lscope6-.LFBB6
 510               		.stabd	78,0,0
 511               		.stabs	"_Z11draw_spriteP6sprite:F(0,4)",36,0,204,_Z11draw_spriteP6sprite
 512               		.stabs	"spr:P(0,96)=*(0,90)",64,0,204,16
 513               	.global	_Z11draw_spriteP6sprite
 514               		.type	_Z11draw_spriteP6sprite, @function
 515               	_Z11draw_spriteP6sprite:
 516               		.stabd	46,0,0
 203:ttris.cpp     **** 
 204:ttris.cpp     **** void draw_sprite(sprite* spr)
 205:ttris.cpp     **** {
 517               		.stabn	68,0,205,.LM48-.LFBB7
 518               	.LM48:
 519               	.LFBB7:
 520 0168 EF92      		push r14
 521 016a FF92      		push r15
 522 016c 0F93      		push r16
 523 016e 1F93      		push r17
 524 0170 CF93      		push r28
 525 0172 DF93      		push r29
 526               	/* prologue: function */
 527               	/* frame size = 0 */
 528               	/* stack size = 6 */
 529               	.L__stack_usage = 6
 530 0174 8C01      		movw r16,r24
 531               	.LBB34:
 206:ttris.cpp     ****   for(int y = 0; y < spr->hght; y++)
 532               		.stabn	68,0,206,.LM49-.LFBB7
 533               	.LM49:
 534 0176 C0E0      		ldi r28,0
 535 0178 D0E0      		ldi r29,0
 536               	.L27:
 537               		.stabn	68,0,206,.LM50-.LFBB7
 538               	.LM50:
 539 017a F801      		movw r30,r16
 540 017c 8285      		ldd r24,Z+10
 541 017e 9385      		ldd r25,Z+11
 542 0180 C817      		cp r28,r24
 543 0182 D907      		cpc r29,r25
 544 0184 04F4      		brge .L34
 545 0186 E12C      		mov r14,__zero_reg__
 546 0188 F12C      		mov r15,__zero_reg__
 547               	.L31:
 548               	.LBB35:
 207:ttris.cpp     ****   {
 208:ttris.cpp     ****     for(int x = 0; x < spr->wdth; x++)
 549               		.stabn	68,0,208,.LM51-.LFBB7
 550               	.LM51:
 551 018a F801      		movw r30,r16
 552 018c 8085      		ldd r24,Z+8
 553 018e 9185      		ldd r25,Z+9
 554 0190 E816      		cp r14,r24
 555 0192 F906      		cpc r15,r25
 556 0194 04F4      		brge .L35
 209:ttris.cpp     ****     {
 210:ttris.cpp     ****       if(read_pixel(spr->x_map + x, spr->y_map + y, spritemap))
 557               		.stabn	68,0,210,.LM52-.LFBB7
 558               	.LM52:
 559 0196 F801      		movw r30,r16
 560 0198 6281      		ldd r22,Z+2
 561 019a 7381      		ldd r23,Z+3
 562 019c 6C0F      		add r22,r28
 563 019e 7D1F      		adc r23,r29
 564 01a0 8081      		ld r24,Z
 565 01a2 9181      		ldd r25,Z+1
 566 01a4 40E0      		ldi r20,lo8(spritemap)
 567 01a6 50E0      		ldi r21,hi8(spritemap)
 568 01a8 8E0D      		add r24,r14
 569 01aa 9F1D      		adc r25,r15
 570 01ac 0E94 0000 		call _Z10read_pixeliiPA84_h
 571 01b0 F801      		movw r30,r16
 572 01b2 6681      		ldd r22,Z+6
 573 01b4 7781      		ldd r23,Z+7
 574 01b6 2481      		ldd r18,Z+4
 575 01b8 3581      		ldd r19,Z+5
 211:ttris.cpp     ****       {
 212:ttris.cpp     ****         set_pixel(spr->x_pos + x, spr->y_pos + y, BLACK);
 576               		.stabn	68,0,212,.LM53-.LFBB7
 577               	.LM53:
 578 01ba 6C0F      		add r22,r28
 579 01bc 7D1F      		adc r23,r29
 210:ttris.cpp     ****       {
 580               		.stabn	68,0,210,.LM54-.LFBB7
 581               	.LM54:
 582 01be 8823      		tst r24
 583 01c0 01F0      		breq .L28
 584               		.stabn	68,0,212,.LM55-.LFBB7
 585               	.LM55:
 586 01c2 41E0      		ldi r20,lo8(1)
 587 01c4 00C0      		rjmp .L33
 588               	.L28:
 213:ttris.cpp     ****       }
 214:ttris.cpp     ****       else
 215:ttris.cpp     ****       {
 216:ttris.cpp     ****         set_pixel(spr->x_pos + x, spr->y_pos + y, WHITE);
 589               		.stabn	68,0,216,.LM56-.LFBB7
 590               	.LM56:
 591 01c6 40E0      		ldi r20,0
 592               	.L33:
 593 01c8 C701      		movw r24,r14
 594 01ca 820F      		add r24,r18
 595 01cc 931F      		adc r25,r19
 596 01ce 0E94 0000 		call _Z9set_pixeliib
 208:ttris.cpp     ****     {
 597               		.stabn	68,0,208,.LM57-.LFBB7
 598               	.LM57:
 599 01d2 FFEF      		ldi r31,-1
 600 01d4 EF1A      		sub r14,r31
 601 01d6 FF0A      		sbc r15,r31
 602 01d8 00C0      		rjmp .L31
 603               	.L35:
 604               	.LBE35:
 206:ttris.cpp     ****   {
 605               		.stabn	68,0,206,.LM58-.LFBB7
 606               	.LM58:
 607 01da 2196      		adiw r28,1
 608 01dc 00C0      		rjmp .L27
 609               	.L34:
 610               	/* epilogue start */
 611               	.LBE34:
 217:ttris.cpp     ****       }
 218:ttris.cpp     ****     }
 219:ttris.cpp     ****   }
 220:ttris.cpp     **** }
 612               		.stabn	68,0,220,.LM59-.LFBB7
 613               	.LM59:
 614 01de DF91      		pop r29
 615 01e0 CF91      		pop r28
 616 01e2 1F91      		pop r17
 617 01e4 0F91      		pop r16
 618 01e6 FF90      		pop r15
 619 01e8 EF90      		pop r14
 620 01ea 0895      		ret
 621               		.size	_Z11draw_spriteP6sprite, .-_Z11draw_spriteP6sprite
 622               		.stabs	"y:r(0,9)",64,0,206,28
 623               		.stabn	192,0,0,.LBB34-.LFBB7
 624               		.stabs	"x:r(0,9)",64,0,208,14
 625               		.stabn	192,0,0,.LBB35-.LFBB7
 626               		.stabn	224,0,0,.LBE35-.LFBB7
 627               		.stabn	224,0,0,.LBE34-.LFBB7
 628               	.Lscope7:
 629               		.stabs	"",36,0,0,.Lscope7-.LFBB7
 630               		.stabd	78,0,0
 631               		.stabs	"_Z21get_sprite_char_y_mapc:F(0,9)",36,0,222,_Z21get_sprite_char_y_mapc
 632               		.stabs	"c:P(0,17)",64,0,222,24
 633               	.global	_Z21get_sprite_char_y_mapc
 634               		.type	_Z21get_sprite_char_y_mapc, @function
 635               	_Z21get_sprite_char_y_mapc:
 636               		.stabd	46,0,0
 221:ttris.cpp     **** 
 222:ttris.cpp     **** int get_sprite_char_y_map(char c)
 223:ttris.cpp     **** {
 637               		.stabn	68,0,223,.LM60-.LFBB8
 638               	.LM60:
 639               	.LFBB8:
 640               	/* prologue: function */
 641               	/* frame size = 0 */
 642               	/* stack size = 0 */
 643               	.L__stack_usage = 0
 224:ttris.cpp     ****   if (((c >= '0') && (c <= '9')) || ((c >= 'A') && (c <= 'D')))
 644               		.stabn	68,0,224,.LM61-.LFBB8
 645               	.LM61:
 646 01ec 90ED      		ldi r25,lo8(-48)
 647 01ee 980F      		add r25,r24
 648 01f0 9A30      		cpi r25,lo8(10)
 649 01f2 00F0      		brlo .L39
 650               		.stabn	68,0,224,.LM62-.LFBB8
 651               	.LM62:
 652 01f4 9FEB      		ldi r25,lo8(-65)
 653 01f6 980F      		add r25,r24
 654 01f8 9430      		cpi r25,lo8(4)
 655 01fa 00F0      		brlo .L39
 225:ttris.cpp     ****   {
 226:ttris.cpp     ****     return 0;
 227:ttris.cpp     ****   }
 228:ttris.cpp     **** 
 229:ttris.cpp     ****   if((c >= 'E') && (c <= 'R'))
 656               		.stabn	68,0,229,.LM63-.LFBB8
 657               	.LM63:
 658 01fc 9BEB      		ldi r25,lo8(-69)
 659 01fe 980F      		add r25,r24
 660 0200 9E30      		cpi r25,lo8(14)
 661 0202 00F0      		brlo .L40
 230:ttris.cpp     ****   {
 231:ttris.cpp     ****     return 4;
 232:ttris.cpp     ****   }
 233:ttris.cpp     **** 
 234:ttris.cpp     ****   if((c >= 'S') && (c <= 'Z'))
 662               		.stabn	68,0,234,.LM64-.LFBB8
 663               	.LM64:
 664 0204 9DEA      		ldi r25,lo8(-83)
 665 0206 980F      		add r25,r24
 666 0208 9830      		cpi r25,lo8(8)
 667 020a 00F0      		brlo .L41
 235:ttris.cpp     ****   {
 236:ttris.cpp     ****     return 8;
 237:ttris.cpp     ****   }
 238:ttris.cpp     ****   if(c == ' ')
 668               		.stabn	68,0,238,.LM65-.LFBB8
 669               	.LM65:
 670 020c 8032      		cpi r24,lo8(32)
 671 020e 01F0      		breq .L42
 672               	.L39:
 226:ttris.cpp     ****   }
 673               		.stabn	68,0,226,.LM66-.LFBB8
 674               	.LM66:
 675 0210 80E0      		ldi r24,0
 676 0212 90E0      		ldi r25,0
 677 0214 0895      		ret
 678               	.L40:
 231:ttris.cpp     ****   }
 679               		.stabn	68,0,231,.LM67-.LFBB8
 680               	.LM67:
 681 0216 84E0      		ldi r24,lo8(4)
 682 0218 90E0      		ldi r25,0
 683 021a 0895      		ret
 684               	.L41:
 236:ttris.cpp     ****   }
 685               		.stabn	68,0,236,.LM68-.LFBB8
 686               	.LM68:
 687 021c 88E0      		ldi r24,lo8(8)
 688 021e 90E0      		ldi r25,0
 689 0220 0895      		ret
 690               	.L42:
 239:ttris.cpp     ****   {
 240:ttris.cpp     ****     return 13;
 691               		.stabn	68,0,240,.LM69-.LFBB8
 692               	.LM69:
 693 0222 8DE0      		ldi r24,lo8(13)
 694 0224 90E0      		ldi r25,0
 241:ttris.cpp     ****   }
 242:ttris.cpp     ****   else
 243:ttris.cpp     ****   {
 244:ttris.cpp     ****     return 0;
 245:ttris.cpp     ****   }
 246:ttris.cpp     **** }
 695               		.stabn	68,0,246,.LM70-.LFBB8
 696               	.LM70:
 697 0226 0895      		ret
 698               		.size	_Z21get_sprite_char_y_mapc, .-_Z21get_sprite_char_y_mapc
 699               	.Lscope8:
 700               		.stabs	"",36,0,0,.Lscope8-.LFBB8
 701               		.stabd	78,0,0
 702               		.stabs	"_Z21get_sprite_char_x_mapc:F(0,9)",36,0,248,_Z21get_sprite_char_x_mapc
 703               		.stabs	"c:P(0,17)",64,0,248,18
 704               	.global	_Z21get_sprite_char_x_mapc
 705               		.type	_Z21get_sprite_char_x_mapc, @function
 706               	_Z21get_sprite_char_x_mapc:
 707               		.stabd	46,0,0
 247:ttris.cpp     **** 
 248:ttris.cpp     **** int get_sprite_char_x_map(char c)
 249:ttris.cpp     **** {
 708               		.stabn	68,0,249,.LM71-.LFBB9
 709               	.LM71:
 710               	.LFBB9:
 711               	/* prologue: function */
 712               	/* frame size = 0 */
 713               	/* stack size = 0 */
 714               	.L__stack_usage = 0
 715 0228 282F      		mov r18,r24
 250:ttris.cpp     ****   if((c >= '0') && (c <= '9'))
 716               		.stabn	68,0,250,.LM72-.LFBB9
 717               	.LM72:
 718 022a 80ED      		ldi r24,lo8(-48)
 719 022c 820F      		add r24,r18
 720 022e 8A30      		cpi r24,lo8(10)
 721 0230 00F4      		brsh .L44
 251:ttris.cpp     ****   {
 252:ttris.cpp     ****     return ((c-'0')*6);
 722               		.stabn	68,0,252,.LM73-.LFBB9
 723               	.LM73:
 724 0232 022E      		mov __tmp_reg__,r18
 725 0234 000C      		lsl r0
 726 0236 330B      		sbc r19,r19
 727 0238 2053      		subi r18,48
 728 023a 3109      		sbc r19,__zero_reg__
 729 023c 00C0      		rjmp .L50
 730               	.L44:
 253:ttris.cpp     ****   }
 254:ttris.cpp     **** 
 255:ttris.cpp     ****   if((c >= 'A') && (c <= 'D'))
 731               		.stabn	68,0,255,.LM74-.LFBB9
 732               	.LM74:
 733 023e 8FEB      		ldi r24,lo8(-65)
 734 0240 820F      		add r24,r18
 735 0242 8430      		cpi r24,lo8(4)
 736 0244 00F4      		brsh .L46
 256:ttris.cpp     ****   {
 257:ttris.cpp     ****     return ((c-'A'+10)*6);
 737               		.stabn	68,0,257,.LM75-.LFBB9
 738               	.LM75:
 739 0246 022E      		mov __tmp_reg__,r18
 740 0248 000C      		lsl r0
 741 024a 330B      		sbc r19,r19
 742 024c 2753      		subi r18,55
 743 024e 3109      		sbc r19,__zero_reg__
 744 0250 00C0      		rjmp .L50
 745               	.L46:
 258:ttris.cpp     ****   }
 259:ttris.cpp     **** 
 260:ttris.cpp     ****   if((c >= 'E') && (c <= 'R'))
 746               		.stabn	68,0,260,.LM76-.LFBB9
 747               	.LM76:
 748 0252 8BEB      		ldi r24,lo8(-69)
 749 0254 820F      		add r24,r18
 750 0256 8E30      		cpi r24,lo8(14)
 751 0258 00F4      		brsh .L47
 261:ttris.cpp     ****   {
 262:ttris.cpp     ****     return ((c-'E')*6);
 752               		.stabn	68,0,262,.LM77-.LFBB9
 753               	.LM77:
 754 025a 822F      		mov r24,r18
 755 025c 220F      		lsl r18
 756 025e 990B      		sbc r25,r25
 757 0260 9C01      		movw r18,r24
 758 0262 2554      		subi r18,69
 759 0264 3109      		sbc r19,__zero_reg__
 760 0266 00C0      		rjmp .L50
 761               	.L47:
 263:ttris.cpp     ****   }
 264:ttris.cpp     **** 
 265:ttris.cpp     ****   if((c >= 'S') && (c <= 'Z'))
 762               		.stabn	68,0,265,.LM78-.LFBB9
 763               	.LM78:
 764 0268 8DEA      		ldi r24,lo8(-83)
 765 026a 820F      		add r24,r18
 766 026c 8830      		cpi r24,lo8(8)
 767 026e 00F4      		brsh .L48
 266:ttris.cpp     ****   {
 267:ttris.cpp     ****     return ((c-'S')*6);
 768               		.stabn	68,0,267,.LM79-.LFBB9
 769               	.LM79:
 770 0270 822F      		mov r24,r18
 771 0272 220F      		lsl r18
 772 0274 990B      		sbc r25,r25
 773 0276 9C01      		movw r18,r24
 774 0278 2355      		subi r18,83
 775 027a 3109      		sbc r19,__zero_reg__
 776               	.L50:
 777 027c 46E0      		ldi r20,lo8(6)
 778 027e 429F      		mul r20,r18
 779 0280 C001      		movw r24,r0
 780 0282 439F      		mul r20,r19
 781 0284 900D      		add r25,r0
 782 0286 1124      		clr __zero_reg__
 783 0288 0895      		ret
 784               	.L48:
 268:ttris.cpp     ****   }
 269:ttris.cpp     ****   if(c == ' ')
 785               		.stabn	68,0,269,.LM80-.LFBB9
 786               	.LM80:
 787 028a 2032      		cpi r18,lo8(32)
 788 028c 01F0      		breq .L49
 270:ttris.cpp     ****   {
 271:ttris.cpp     ****     return 43;
 272:ttris.cpp     ****   }
 273:ttris.cpp     ****   else
 274:ttris.cpp     ****   {
 275:ttris.cpp     ****     return 0;
 789               		.stabn	68,0,275,.LM81-.LFBB9
 790               	.LM81:
 791 028e 80E0      		ldi r24,0
 792 0290 90E0      		ldi r25,0
 793 0292 0895      		ret
 794               	.L49:
 271:ttris.cpp     ****   }
 795               		.stabn	68,0,271,.LM82-.LFBB9
 796               	.LM82:
 797 0294 8BE2      		ldi r24,lo8(43)
 798 0296 90E0      		ldi r25,0
 276:ttris.cpp     ****   }
 277:ttris.cpp     **** }
 799               		.stabn	68,0,277,.LM83-.LFBB9
 800               	.LM83:
 801 0298 0895      		ret
 802               		.size	_Z21get_sprite_char_x_mapc, .-_Z21get_sprite_char_x_mapc
 803               	.Lscope9:
 804               		.stabs	"",36,0,0,.Lscope9-.LFBB9
 805               		.stabd	78,0,0
 806               		.stabs	"_Z11draw_stringP13string_sprite:F(0,4)",36,0,279,_Z11draw_stringP13string_sprite
 807               		.stabs	"str:P(0,97)=*(0,91)",64,0,279,14
 808               	.global	_Z11draw_stringP13string_sprite
 809               		.type	_Z11draw_stringP13string_sprite, @function
 810               	_Z11draw_stringP13string_sprite:
 811               		.stabd	46,0,0
 278:ttris.cpp     **** 
 279:ttris.cpp     **** void draw_string(string_sprite* str)
 280:ttris.cpp     **** {
 812               		.stabn	68,0,280,.LM84-.LFBB10
 813               	.LM84:
 814               	.LFBB10:
 815 029a AF92      		push r10
 816 029c BF92      		push r11
 817 029e CF92      		push r12
 818 02a0 DF92      		push r13
 819 02a2 EF92      		push r14
 820 02a4 FF92      		push r15
 821 02a6 0F93      		push r16
 822 02a8 1F93      		push r17
 823 02aa CF93      		push r28
 824 02ac DF93      		push r29
 825 02ae CDB7      		in r28,__SP_L__
 826 02b0 DEB7      		in r29,__SP_H__
 827 02b2 2C97      		sbiw r28,12
 828 02b4 0FB6      		in __tmp_reg__,__SREG__
 829 02b6 F894      		cli
 830 02b8 DEBF      		out __SP_H__,r29
 831 02ba 0FBE      		out __SREG__,__tmp_reg__
 832 02bc CDBF      		out __SP_L__,r28
 833               	/* prologue: function */
 834               	/* frame size = 12 */
 835               	/* stack size = 22 */
 836               	.L__stack_usage = 22
 837 02be 7C01      		movw r14,r24
 838               	.LBB36:
 281:ttris.cpp     ****   struct sprite c;
 282:ttris.cpp     ****   c.x_pos = str->x_pos;
 839               		.stabn	68,0,282,.LM85-.LFBB10
 840               	.LM85:
 841 02c0 FC01      		movw r30,r24
 842 02c2 8081      		ld r24,Z
 843 02c4 9181      		ldd r25,Z+1
 844 02c6 9E83      		std Y+6,r25
 845 02c8 8D83      		std Y+5,r24
 283:ttris.cpp     ****   c.wdth = 6;
 846               		.stabn	68,0,283,.LM86-.LFBB10
 847               	.LM86:
 848 02ca 86E0      		ldi r24,lo8(6)
 849 02cc 90E0      		ldi r25,0
 850 02ce 9A87      		std Y+10,r25
 851 02d0 8987      		std Y+9,r24
 284:ttris.cpp     ****   c.hght = 4;
 852               		.stabn	68,0,284,.LM87-.LFBB10
 853               	.LM87:
 854 02d2 84E0      		ldi r24,lo8(4)
 855 02d4 90E0      		ldi r25,0
 856 02d6 9C87      		std Y+12,r25
 857 02d8 8B87      		std Y+11,r24
 858               	.LBB37:
 285:ttris.cpp     ****   for(int i = 0; str->str[i] != '\0'; i++)
 859               		.stabn	68,0,285,.LM88-.LFBB10
 860               	.LM88:
 861 02da C12C      		mov r12,__zero_reg__
 862 02dc D12C      		mov r13,__zero_reg__
 863 02de A12C      		mov r10,__zero_reg__
 864 02e0 B12C      		mov r11,__zero_reg__
 865               	.L52:
 866               		.stabn	68,0,285,.LM89-.LFBB10
 867               	.LM89:
 868 02e2 F701      		movw r30,r14
 869 02e4 0481      		ldd r16,Z+4
 870 02e6 1581      		ldd r17,Z+5
 871 02e8 0A0D      		add r16,r10
 872 02ea 1B1D      		adc r17,r11
 873 02ec F801      		movw r30,r16
 874 02ee 8081      		ld r24,Z
 875 02f0 8823      		tst r24
 876 02f2 01F0      		breq .L54
 286:ttris.cpp     ****   {
 287:ttris.cpp     ****     c.x_map = get_sprite_char_x_map(str->str[i]);
 877               		.stabn	68,0,287,.LM90-.LFBB10
 878               	.LM90:
 879 02f4 0E94 0000 		call _Z21get_sprite_char_x_mapc
 880 02f8 9A83      		std Y+2,r25
 881 02fa 8983      		std Y+1,r24
 288:ttris.cpp     ****     c.y_map = get_sprite_char_y_map(str->str[i]);
 882               		.stabn	68,0,288,.LM91-.LFBB10
 883               	.LM91:
 884 02fc F801      		movw r30,r16
 885 02fe 8081      		ld r24,Z
 886 0300 0E94 0000 		call _Z21get_sprite_char_y_mapc
 887 0304 9C83      		std Y+4,r25
 888 0306 8B83      		std Y+3,r24
 289:ttris.cpp     ****     c.y_pos = ((str->y_pos - (i*4))-4);
 889               		.stabn	68,0,289,.LM92-.LFBB10
 890               	.LM92:
 891 0308 F701      		movw r30,r14
 892 030a 2281      		ldd r18,Z+2
 893 030c 3381      		ldd r19,Z+3
 894 030e 2C0D      		add r18,r12
 895 0310 3D1D      		adc r19,r13
 896 0312 2450      		subi r18,4
 897 0314 3109      		sbc r19,__zero_reg__
 898 0316 3887      		std Y+8,r19
 899 0318 2F83      		std Y+7,r18
 290:ttris.cpp     ****     draw_sprite(&c);
 900               		.stabn	68,0,290,.LM93-.LFBB10
 901               	.LM93:
 902 031a CE01      		movw r24,r28
 903 031c 0196      		adiw r24,1
 904 031e 0E94 0000 		call _Z11draw_spriteP6sprite
 285:ttris.cpp     ****   {
 905               		.stabn	68,0,285,.LM94-.LFBB10
 906               	.LM94:
 907 0322 FFEF      		ldi r31,-1
 908 0324 AF1A      		sub r10,r31
 909 0326 BF0A      		sbc r11,r31
 910 0328 84E0      		ldi r24,4
 911 032a C81A      		sub r12,r24
 912 032c D108      		sbc r13,__zero_reg__
 913 032e 00C0      		rjmp .L52
 914               	.L54:
 915               	/* epilogue start */
 916               	.LBE37:
 917               	.LBE36:
 291:ttris.cpp     ****   }
 292:ttris.cpp     **** }
 918               		.stabn	68,0,292,.LM95-.LFBB10
 919               	.LM95:
 920 0330 2C96      		adiw r28,12
 921 0332 0FB6      		in __tmp_reg__,__SREG__
 922 0334 F894      		cli
 923 0336 DEBF      		out __SP_H__,r29
 924 0338 0FBE      		out __SREG__,__tmp_reg__
 925 033a CDBF      		out __SP_L__,r28
 926 033c DF91      		pop r29
 927 033e CF91      		pop r28
 928 0340 1F91      		pop r17
 929 0342 0F91      		pop r16
 930 0344 FF90      		pop r15
 931 0346 EF90      		pop r14
 932 0348 DF90      		pop r13
 933 034a CF90      		pop r12
 934 034c BF90      		pop r11
 935 034e AF90      		pop r10
 936 0350 0895      		ret
 937               		.size	_Z11draw_stringP13string_sprite, .-_Z11draw_stringP13string_sprite
 938               		.stabs	"c:(0,90)",128,0,281,1
 939               		.stabn	192,0,0,.LBB36-.LFBB10
 940               		.stabs	"i:r(0,9)",64,0,285,10
 941               		.stabn	192,0,0,.LBB37-.LFBB10
 942               		.stabn	224,0,0,.LBE37-.LFBB10
 943               		.stabn	224,0,0,.LBE36-.LFBB10
 944               	.Lscope10:
 945               		.stabs	"",36,0,0,.Lscope10-.LFBB10
 946               		.stabd	78,0,0
 947               		.section	.rodata.str1.1,"aMS",@progbits,1
 948               	.LC0:
 949 0000 5445 5452 		.string	"TETRIS"
 949      4953 00
 950               	.LC1:
 951 0007 534A 5355 		.string	"SJSU GAMEDEV"
 951      2047 414D 
 951      4544 4556 
 951      00
 952               		.section	.text.startup,"ax",@progbits
 953               		.stabs	"main:F(0,9)",36,0,294,main
 954               	.global	main
 955               		.type	main, @function
 956               	main:
 957               		.stabd	46,0,0
 293:ttris.cpp     **** 
 294:ttris.cpp     **** int main(void)
 295:ttris.cpp     **** {
 958               		.stabn	68,0,295,.LM96-.LFBB11
 959               	.LM96:
 960               	.LFBB11:
 961 0000 CF93      		push r28
 962 0002 DF93      		push r29
 963 0004 CDB7      		in r28,__SP_L__
 964 0006 DEB7      		in r29,__SP_H__
 965 0008 A097      		sbiw r28,32
 966 000a 0FB6      		in __tmp_reg__,__SREG__
 967 000c F894      		cli
 968 000e DEBF      		out __SP_H__,r29
 969 0010 0FBE      		out __SREG__,__tmp_reg__
 970 0012 CDBF      		out __SP_L__,r28
 971               	/* prologue: function */
 972               	/* frame size = 32 */
 973               	/* stack size = 34 */
 974               	.L__stack_usage = 34
 975               	.LBB38:
 296:ttris.cpp     ****   struct sprite zero;
 297:ttris.cpp     ****   zero.x_map = 0;
 298:ttris.cpp     ****   zero.y_map = 0;
 299:ttris.cpp     ****   zero.x_pos = 0;
 300:ttris.cpp     ****   zero.y_pos = 0;
 301:ttris.cpp     ****   zero.wdth = 6;
 302:ttris.cpp     ****   zero.hght = 4;
 303:ttris.cpp     **** 
 304:ttris.cpp     ****   struct string_sprite tetris;
 305:ttris.cpp     ****   struct string_sprite sjsu;
 306:ttris.cpp     ****   char tetris_s[] = "TETRIS";
 976               		.stabn	68,0,306,.LM97-.LFBB11
 977               	.LM97:
 978 0014 87E0      		ldi r24,lo8(7)
 979 0016 E0E0      		ldi r30,lo8(.LC0)
 980 0018 F0E0      		ldi r31,hi8(.LC0)
 981 001a DE01      		movw r26,r28
 982 001c 1E96      		adiw r26,14
 983               		0:
 984 001e 0190      		ld r0,Z+
 985 0020 0D92      		st X+,r0
 986 0022 8A95      		dec r24
 987 0024 01F4      		brne 0b
 307:ttris.cpp     ****   char sjsu_s[] = "SJSU GAMEDEV";
 988               		.stabn	68,0,307,.LM98-.LFBB11
 989               	.LM98:
 990 0026 8DE0      		ldi r24,lo8(13)
 991 0028 E0E0      		ldi r30,lo8(.LC1)
 992 002a F0E0      		ldi r31,hi8(.LC1)
 993 002c 9E01      		movw r18,r28
 994 002e 2F5F      		subi r18,-1
 995 0030 3F4F      		sbci r19,-1
 996 0032 D901      		movw r26,r18
 997               		0:
 998 0034 0190      		ld r0,Z+
 999 0036 0D92      		st X+,r0
 1000 0038 8A95      		dec r24
 1001 003a 01F4      		brne 0b
 308:ttris.cpp     ****   tetris.str = tetris_s;
 1002               		.stabn	68,0,308,.LM99-.LFBB11
 1003               	.LM99:
 1004 003c CE01      		movw r24,r28
 1005 003e 0E96      		adiw r24,14
 1006 0040 98A3      		std Y+32,r25
 1007 0042 8F8F      		std Y+31,r24
 309:ttris.cpp     ****   tetris.x_pos = 0;
 1008               		.stabn	68,0,309,.LM100-.LFBB11
 1009               	.LM100:
 1010 0044 1C8E      		std Y+28,__zero_reg__
 1011 0046 1B8E      		std Y+27,__zero_reg__
 310:ttris.cpp     ****   tetris.y_pos = 48;
 1012               		.stabn	68,0,310,.LM101-.LFBB11
 1013               	.LM101:
 1014 0048 80E3      		ldi r24,lo8(48)
 1015 004a 90E0      		ldi r25,0
 1016 004c 9E8F      		std Y+30,r25
 1017 004e 8D8F      		std Y+29,r24
 311:ttris.cpp     ****   sjsu.str = sjsu_s;
 1018               		.stabn	68,0,311,.LM102-.LFBB11
 1019               	.LM102:
 1020 0050 3A8F      		std Y+26,r19
 1021 0052 298F      		std Y+25,r18
 312:ttris.cpp     ****   sjsu.x_pos = 6;
 1022               		.stabn	68,0,312,.LM103-.LFBB11
 1023               	.LM103:
 1024 0054 26E0      		ldi r18,lo8(6)
 1025 0056 30E0      		ldi r19,0
 1026 0058 3E8B      		std Y+22,r19
 1027 005a 2D8B      		std Y+21,r18
 313:ttris.cpp     ****   sjsu.y_pos = 48;
 1028               		.stabn	68,0,313,.LM104-.LFBB11
 1029               	.LM104:
 1030 005c 988F      		std Y+24,r25
 1031 005e 8F8B      		std Y+23,r24
 1032               	.LBB39:
 1033               	.LBB40:
 1034               		.stabs	"/usr/lib/avr/include/util/delay.h",132,0,0,.Ltext1
 1035               	.Ltext1:
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/lib/avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/lib/avr/include/util/delay.h **** #endif
  41:/usr/lib/avr/include/util/delay.h **** 
  42:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  45:/usr/lib/avr/include/util/delay.h **** 
  46:/usr/lib/avr/include/util/delay.h **** /** \file */
  47:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/lib/avr/include/util/delay.h ****     \code
  49:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/lib/avr/include/util/delay.h ****     \endcode
  53:/usr/lib/avr/include/util/delay.h **** 
  54:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/lib/avr/include/util/delay.h ****     used.
  58:/usr/lib/avr/include/util/delay.h **** 
  59:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/lib/avr/include/util/delay.h **** 
  68:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/lib/avr/include/util/delay.h **** 
  77:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/lib/avr/include/util/delay.h **** 
  81:/usr/lib/avr/include/util/delay.h **** */
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/lib/avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/lib/avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/lib/avr/include/util/delay.h **** #endif
  87:/usr/lib/avr/include/util/delay.h **** 
  88:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/lib/avr/include/util/delay.h **** #endif
  93:/usr/lib/avr/include/util/delay.h **** 
  94:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/lib/avr/include/util/delay.h **** #endif
  97:/usr/lib/avr/include/util/delay.h **** 
  98:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 102:/usr/lib/avr/include/util/delay.h **** #endif
 103:/usr/lib/avr/include/util/delay.h **** 
 104:/usr/lib/avr/include/util/delay.h **** /**
 105:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/lib/avr/include/util/delay.h **** 
 107:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/lib/avr/include/util/delay.h **** 
 109:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/lib/avr/include/util/delay.h **** 
 112:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/lib/avr/include/util/delay.h **** 
 114:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/lib/avr/include/util/delay.h **** 
 120:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/lib/avr/include/util/delay.h **** 
 125:/usr/lib/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/lib/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/lib/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/lib/avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/lib/avr/include/util/delay.h **** 
 132:/usr/lib/avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/lib/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/lib/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/lib/avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/lib/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/lib/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/lib/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/lib/avr/include/util/delay.h **** 
 140:/usr/lib/avr/include/util/delay.h ****  */
 141:/usr/lib/avr/include/util/delay.h **** void
 142:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/lib/avr/include/util/delay.h **** {
 144:/usr/lib/avr/include/util/delay.h **** 	double __tmp ; 
 145:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 146:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 147:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 148:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 149:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 150:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 151:/usr/lib/avr/include/util/delay.h **** 
 152:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 153:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 154:/usr/lib/avr/include/util/delay.h **** 
 155:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 156:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 157:/usr/lib/avr/include/util/delay.h **** 
 158:/usr/lib/avr/include/util/delay.h **** 	#else
 159:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 160:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 161:/usr/lib/avr/include/util/delay.h **** 	#endif
 162:/usr/lib/avr/include/util/delay.h **** 
 163:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 1036               		.stabn	68,0,163,.LM105-.LFBB11
 1037               	.LM105:
 1038 0060 2FEF      		ldi r18,lo8(639999)
 1039 0062 83EC      		ldi r24,hi8(639999)
 1040 0064 99E0      		ldi r25,hlo8(639999)
 1041 0066 2150      	1:	subi r18,1
 1042 0068 8040      		sbci r24,0
 1043 006a 9040      		sbci r25,0
 1044 006c 01F4      		brne 1b
 1045 006e 00C0      		rjmp .
 1046 0070 0000      		nop
 1047               	.LBE40:
 1048               	.LBE39:
 1049               		.stabs	"ttris.cpp",132,0,0,.Ltext2
 1050               	.Ltext2:
 314:ttris.cpp     ****   //Give the AVR a bit to boot
 315:ttris.cpp     ****   _delay_ms(200);
 316:ttris.cpp     ****   //Initialize the SPI bus
 317:ttris.cpp     ****   spi_init_master();
 1051               		.stabn	68,0,317,.LM106-.LFBB11
 1052               	.LM106:
 1053 0072 0E94 0000 		call _Z15spi_init_masterv
 318:ttris.cpp     ****   //Initialize the screen
 319:ttris.cpp     ****   init_screen();
 1054               		.stabn	68,0,319,.LM107-.LFBB11
 1055               	.LM107:
 1056 0076 0E94 0000 		call _Z11init_screenv
 320:ttris.cpp     ****   blank_display();
 1057               		.stabn	68,0,320,.LM108-.LFBB11
 1058               	.LM108:
 1059 007a 0E94 0000 		call _Z13blank_displayv
 321:ttris.cpp     ****   //draw a test pattern
 322:ttris.cpp     ****   //draw_sprite(&zero);
 323:ttris.cpp     ****   draw_string(&tetris);
 1060               		.stabn	68,0,323,.LM109-.LFBB11
 1061               	.LM109:
 1062 007e CE01      		movw r24,r28
 1063 0080 4B96      		adiw r24,27
 1064 0082 0E94 0000 		call _Z11draw_stringP13string_sprite
 324:ttris.cpp     ****   draw_string(&sjsu);
 1065               		.stabn	68,0,324,.LM110-.LFBB11
 1066               	.LM110:
 1067 0086 CE01      		movw r24,r28
 1068 0088 4596      		adiw r24,21
 1069 008a 0E94 0000 		call _Z11draw_stringP13string_sprite
 1070               	.LBE38:
 325:ttris.cpp     ****   return(0);
 326:ttris.cpp     **** }
 1071               		.stabn	68,0,326,.LM111-.LFBB11
 1072               	.LM111:
 1073 008e 80E0      		ldi r24,0
 1074 0090 90E0      		ldi r25,0
 1075               	/* epilogue start */
 1076 0092 A096      		adiw r28,32
 1077 0094 0FB6      		in __tmp_reg__,__SREG__
 1078 0096 F894      		cli
 1079 0098 DEBF      		out __SP_H__,r29
 1080 009a 0FBE      		out __SREG__,__tmp_reg__
 1081 009c CDBF      		out __SP_L__,r28
 1082 009e DF91      		pop r29
 1083 00a0 CF91      		pop r28
 1084 00a2 0895      		ret
 1085               		.size	main, .-main
 1086               		.stabs	"tetris:(0,91)",128,0,304,27
 1087               		.stabs	"sjsu:(0,91)",128,0,305,21
 1088               		.stabs	"tetris_s:(0,98)=ar(0,95);0;6;(0,17)",128,0,306,14
 1089               		.stabs	"sjsu_s:(0,99)=ar(0,95);0;12;(0,17)",128,0,307,1
 1090               		.stabn	192,0,0,.LBB38-.LFBB11
 1091               		.stabn	224,0,0,.LBE38-.LFBB11
 1092               	.Lscope11:
 1093               		.stabs	"",36,0,0,.Lscope11-.LFBB11
 1094               		.stabd	78,0,0
 1095               	.global	spritemap
 1096               		.data
 1097               		.type	spritemap, @object
 1098               		.size	spritemap, 168
 1099               	spritemap:
 1100 0000 00        		.byte	0
 1101 0001 6E        		.byte	110
 1102 0002 8A        		.byte	-118
 1103 0003 EA        		.byte	-22
 1104 0004 8A        		.byte	-118
 1105 0005 EE        		.byte	-18
 1106 0006 00        		.byte	0
 1107 0007 64        		.byte	100
 1108 0008 84        		.byte	-124
 1109 0009 E4        		.byte	-28
 1110 000a 84        		.byte	-124
 1111 000b 84        		.byte	-124
 1112 000c 00        		.byte	0
 1113 000d 6E        		.byte	110
 1114 000e 82        		.byte	-126
 1115 000f EE        		.byte	-18
 1116 0010 A8        		.byte	-88
 1117 0011 EE        		.byte	-18
 1118 0012 00        		.byte	0
 1119 0013 AE        		.byte	-82
 1120 0014 A2        		.byte	-94
 1121 0015 EE        		.byte	-18
 1122 0016 A2        		.byte	-94
 1123 0017 AE        		.byte	-82
 1124 0018 00        		.byte	0
 1125 0019 EA        		.byte	-22
 1126 001a 4A        		.byte	74
 1127 001b 4E        		.byte	78
 1128 001c 42        		.byte	66
 1129 001d E2        		.byte	-30
 1130 001e 00        		.byte	0
 1131 001f 2E        		.byte	46
 1132 0020 28        		.byte	40
 1133 0021 2E        		.byte	46
 1134 0022 A2        		.byte	-94
 1135 0023 6E        		.byte	110
 1136 0024 00        		.byte	0
 1137 0025 AE        		.byte	-82
 1138 0026 A8        		.byte	-88
 1139 0027 CE        		.byte	-50
 1140 0028 AA        		.byte	-86
 1141 0029 AE        		.byte	-82
 1142 002a 00        		.byte	0
 1143 002b 8E        		.byte	-114
 1144 002c 82        		.byte	-126
 1145 002d 82        		.byte	-126
 1146 002e 82        		.byte	-126
 1147 002f E2        		.byte	-30
 1148 0030 00        		.byte	0
 1149 0031 AE        		.byte	-82
 1150 0032 EA        		.byte	-22
 1151 0033 EE        		.byte	-18
 1152 0034 AA        		.byte	-86
 1153 0035 AE        		.byte	-82
 1154 0036 00        		.byte	0
 1155 0037 AE        		.byte	-82
 1156 0038 EA        		.byte	-22
 1157 0039 EE        		.byte	-18
 1158 003a E2        		.byte	-30
 1159 003b AE        		.byte	-82
 1160 003c 00        		.byte	0
 1161 003d 44        		.byte	68
 1162 003e AA        		.byte	-86
 1163 003f AE        		.byte	-82
 1164 0040 AA        		.byte	-86
 1165 0041 4A        		.byte	74
 1166 0042 00        		.byte	0
 1167 0043 CC        		.byte	-52
 1168 0044 AA        		.byte	-86
 1169 0045 EC        		.byte	-20
 1170 0046 8A        		.byte	-118
 1171 0047 8E        		.byte	-114
 1172 0048 00        		.byte	0
 1173 0049 46        		.byte	70
 1174 004a A8        		.byte	-88
 1175 004b A8        		.byte	-88
 1176 004c E8        		.byte	-24
 1177 004d 6E        		.byte	110
 1178 004e 00        		.byte	0
 1179 004f CC        		.byte	-52
 1180 0050 AA        		.byte	-86
 1181 0051 EA        		.byte	-22
 1182 0052 CA        		.byte	-54
 1183 0053 AE        		.byte	-82
 1184 0054 00        		.byte	0
 1185 0055 46        		.byte	70
 1186 0056 48        		.byte	72
 1187 0057 44        		.byte	68
 1188 0058 02        		.byte	2
 1189 0059 4E        		.byte	78
 1190 005a 00        		.byte	0
 1191 005b EE        		.byte	-18
 1192 005c 24        		.byte	36
 1193 005d 64        		.byte	100
 1194 005e 04        		.byte	4
 1195 005f 44        		.byte	68
 1196 0060 00        		.byte	0
 1197 0061 AA        		.byte	-86
 1198 0062 AA        		.byte	-86
 1199 0063 0A        		.byte	10
 1200 0064 AA        		.byte	-86
 1201 0065 46        		.byte	70
 1202 0066 00        		.byte	0
 1203 0067 AA        		.byte	-86
 1204 0068 4A        		.byte	74
 1205 0069 EA        		.byte	-22
 1206 006a 44        		.byte	68
 1207 006b A4        		.byte	-92
 1208 006c 00        		.byte	0
 1209 006d 0A        		.byte	10
 1210 006e 0A        		.byte	10
 1211 006f 0E        		.byte	14
 1212 0070 0E        		.byte	14
 1213 0071 4A        		.byte	74
 1214 0072 00        		.byte	0
 1215 0073 4A        		.byte	74
 1216 0074 4A        		.byte	74
 1217 0075 04        		.byte	4
 1218 0076 0A        		.byte	10
 1219 0077 0A        		.byte	10
 1220 0078 00        		.byte	0
 1221 0079 EA        		.byte	-22
 1222 007a EA        		.byte	-22
 1223 007b E4        		.byte	-28
 1224 007c E4        		.byte	-28
 1225 007d E4        		.byte	-28
 1226 007e 00        		.byte	0
 1227 007f 0E        		.byte	14
 1228 0080 02        		.byte	2
 1229 0081 04        		.byte	4
 1230 0082 08        		.byte	8
 1231 0083 0E        		.byte	14
 1232 0084 00        		.byte	0
 1233 0085 06        		.byte	6
 1234 0086 06        		.byte	6
 1235 0087 1E        		.byte	30
 1236 0088 1E        		.byte	30
 1237 0089 18        		.byte	24
 1238 008a 18        		.byte	24
 1239 008b 00        		.byte	0
 1240 008c 18        		.byte	24
 1241 008d 18        		.byte	24
 1242 008e 1E        		.byte	30
 1243 008f 1E        		.byte	30
 1244 0090 06        		.byte	6
 1245 0091 06        		.byte	6
 1246 0092 C0        		.byte	-64
 1247 0093 C6        		.byte	-58
 1248 0094 F6        		.byte	-10
 1249 0095 F6        		.byte	-10
 1250 0096 C6        		.byte	-58
 1251 0097 C6        		.byte	-58
 1252 0098 06        		.byte	6
 1253 0099 C6        		.byte	-58
 1254 009a C6        		.byte	-58
 1255 009b C0        		.byte	-64
 1256 009c C6        		.byte	-58
 1257 009d F6        		.byte	-10
 1258 009e F6        		.byte	-10
 1259 009f 06        		.byte	6
 1260 00a0 1E        		.byte	30
 1261 00a1 1E        		.byte	30
 1262 00a2 00        		.byte	0
 1263 00a3 1E        		.byte	30
 1264 00a4 1E        		.byte	30
 1265 00a5 1E        		.byte	30
 1266 00a6 1E        		.byte	30
 1267 00a7 00        		.byte	0
 1268               	.global	fbuff
 1269               		.section .bss
 1270               		.type	fbuff, @object
 1271               		.size	fbuff, 504
 1272               	fbuff:
 1273 0000 0000 0000 		.zero	504
 1273      0000 0000 
 1273      0000 0000 
 1273      0000 0000 
 1273      0000 0000 
 1274               		.stabs	"fbuff:G(0,100)=ar(0,95);0;5;(0,94)",32,0,58,0
 1275               		.stabs	"spritemap:G(0,101)=ar(0,95);0;1;(0,94)",32,0,67,0
 1276               		.text
 1277               		.stabs	"",100,0,0,.Letext0
 1278               	.Letext0:
 1279               		.ident	"GCC: (GNU) 4.9.2"
 1280               	.global __do_copy_data
 1281               	.global __do_clear_bss
DEFINED SYMBOLS
                            *ABS*:0000000000000000 ttris.cpp
     /tmp/cccb04b2.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/cccb04b2.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/cccb04b2.s:4      *ABS*:000000000000003f __SREG__
     /tmp/cccb04b2.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/cccb04b2.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/cccb04b2.s:110    .text:0000000000000000 _Z15spi_init_masterv
     /tmp/cccb04b2.s:137    .text:000000000000000a _Z9send_bytehb
     /tmp/cccb04b2.s:180    .text:000000000000001c _Z11init_screenv
     /tmp/cccb04b2.s:238    .text:0000000000000052 _Z9set_pixeliib
     /tmp/cccb04b2.s:1272   .bss:0000000000000000 fbuff
     /tmp/cccb04b2.s:386    .text:00000000000000e4 _Z13blank_displayv
     /tmp/cccb04b2.s:428    .text:00000000000000fe _Z10read_pixeliiPA84_h
     /tmp/cccb04b2.s:515    .text:0000000000000168 _Z11draw_spriteP6sprite
     /tmp/cccb04b2.s:1099   .data:0000000000000000 spritemap
     /tmp/cccb04b2.s:635    .text:00000000000001ec _Z21get_sprite_char_y_mapc
     /tmp/cccb04b2.s:706    .text:0000000000000228 _Z21get_sprite_char_x_mapc
     /tmp/cccb04b2.s:810    .text:000000000000029a _Z11draw_stringP13string_sprite
     /tmp/cccb04b2.s:956    .text.startup:0000000000000000 main

UNDEFINED SYMBOLS
__divmodhi4
__do_copy_data
__do_clear_bss
