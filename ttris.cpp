#define F_CPU  16000000UL

#include <avr/io.h>
#include <util/delay.h>
#include <avr/interrupt.h>

typedef unsigned char byte;

#define HIGH 1
#define LOW 0

#define BLACK 1
#define WHITE 0

#define DATA 1
#define COMM 0

//Define the SPI Pins to communicate with the screen
//Define the data direction registers
#define DDR_SPI         DDRB
#define DD_SCK          DDB5
#define DD_MISO         DDB4
#define DD_MOSI         DDB3
#define DD_SS           DDB2
#define DD_DC           DDB1
#define DD_RST          DDB0

//Define the port registers
#define PORT_SPI        PORTB
#define PORT_SCK        (1 << PB5) //yellow
#define PORT_MISO       (1 << PB4) //green (unused)
#define PORT_MOSI       (1 << PB3) //white
#define PORT_SS         (1 << PB2) //orange
#define PORT_DC         (1 << PB1) //blue
#define PORT_RST        (1 << PB0) //green

//Init the frame buffer
byte fbuff[6][84] = {
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

//Init the previous frame buffer. This is used to determine which pixels have
//changed between frames and only update the affected pixels
byte pfbuff[6][84] = {
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

byte spritemap[2][84] = {
0x00, 0x6e, 0x8a, 0xea, 0x8a, 0xee, 0x00, 0x64, 0x84, 0xe4, 0x84, 0x84, 0x00, 0x6e, 0x82, 0xee, 0xa8, 0xee, 0x00, 0xae, 0xa2, 0xee, 0xa2, 0xae, 0x00, 0xea, 0x4a, 0x4e, 0x42, 0xe2, 0x00, 0x2e, 0x28, 0x2e, 0xa2, 0x6e, 0x00, 0xae, 0xa8, 0xce, 0xaa, 0xae, 0x00, 0x8e, 0x82, 0x82, 0x82, 0xe2, 0x00, 0xae, 0xea, 0xee, 0xaa, 0xae, 0x00, 0xae, 0xea, 0xee, 0xe2, 0xae, 0x00, 0x44, 0xaa, 0xae, 0xaa, 0x4a, 0x00, 0xcc, 0xaa, 0xec, 0x8a, 0x8e, 0x00, 0x46, 0xa8, 0xa8, 0xe8, 0x6e, 0x00, 0xcc, 0xaa, 0xea, 0xca, 0xae,
0x00, 0x46, 0x48, 0x44, 0x02, 0x4e, 0x00, 0xee, 0x24, 0x64, 0x04, 0x44, 0x00, 0xaa, 0xaa, 0x0a, 0xaa, 0x46, 0x00, 0xaa, 0x4a, 0xea, 0x44, 0xa4, 0x00, 0x0a, 0x0a, 0x0e, 0x0e, 0x4a, 0x00, 0x4a, 0x4a, 0x04, 0x0a, 0x0a, 0x00, 0xea, 0xea, 0xe4, 0xe4, 0xe4, 0x00, 0x0e, 0x02, 0x04, 0x08, 0x0e, 0x00, 0x06, 0x06, 0x1e, 0x1e, 0x18, 0x18, 0x00, 0x18, 0x18, 0x1e, 0x1e, 0x06, 0x06, 0xc0, 0xc6, 0xf6, 0xf6, 0xc6, 0xc6, 0x06, 0xc6, 0xc6, 0xc0, 0xc6, 0xf6, 0xf6, 0x06, 0x1e, 0x1e, 0x00, 0x1e, 0x1e, 0x1e, 0x1e, 0x00, };

struct sprite{
  int x_origin;
  int y_origin;
  int x_pos;
  int y_pos;
  int width;
  int height;
};

// Initialize SPI Master Device (with SPI interrupt)
void spi_init_master (void)
{
    // Set MOSI, SCK, SS, DC, and RST as Output
    DDR_SPI=(1<<DD_MOSI)|(1<<DD_SCK)|(1<<DD_SS)|(1<<DD_DC)|(1<<DD_RST);

    // Enable SPI, Set as Master
    // Prescaler: Fosc/16, Enable Interrupts
    //The MOSI, SCK pins are as per ATMega8
    SPCR=(1<<SPE)|(1<<MSTR)|(1<<SPR0);
}

//Function to send and receive data for both master and slave
void send_byte(byte data, bool dc)
{
    // Load data into the buffer
    SPDR = data;

    //If DC is high, pull the pin high
    if(dc)
    {
      PORT_SPI |= (PORT_DC);
    }

    //Wait until transmission complete
    while(!(SPSR & (1<<SPIF)));

    //Pull DC low again if it was set high
    if(dc)
    {
      PORT_SPI &= ~(PORT_DC);
    }
    return;
}

void screen_init()
{
  /*Enable the screen hardware*/
  //Toggle the reset pin then set it high
  PORT_SPI |= (PORT_RST);
  PORT_SPI &= ~(PORT_RST);
  PORT_SPI |= (PORT_RST);

  //send a byte to init function set
  send_byte(0b00100001, COMM);
  //send byte to init Vop
  send_byte(0b10010000, COMM);
  //send byte to select normal instruction set
  send_byte(0b00100000, COMM);
  //send byte to set screen to normal mode
  send_byte(0b00001100, COMM);
  //set x DDRAM address to 0
  send_byte(0b10000000, COMM);
  //set y DDRAM address to 0
  send_byte(0b01000000, COMM);
}

void set_pixel(int x, int y, bool color)
{
  //if out of bounds
  if(x > 83 || y > 47)
  {
    return;
  }

  //Which byte to manipulate
  int i = y/8;
  //Which bit in the byte to manipulate
  int pos = y%8;
  //Positioning the byte for masking or oring
  byte flag = 0x01;
  flag = flag << pos;

  //If setting it black, bitwise or
  if(color)
  {
    //write the changes to the internal fbuff
    fbuff[i][x] = fbuff[i][x] | flag;
  }

  //If setting it white, mask and bitwise and
  else
  {
    flag = ~flag;
    fbuff[i][x] = fbuff[i][x] & flag;
  }
}

void blank_fbuff(){
  for(int y = 0; y < 6; y++)
  {
    for(int x = 0; x < 84; x++)
    {
      send_byte(0, DATA);
    }
  }
}

void update_frame()
{
  //XOR all the bytes in pfbuff with the corresponding byte in fbuff and store
  //the result in pfbuff
  for(int y = 0; y < 6; y++)
  {
    for(int x = 0; x < 84; x++)
    {
      pfbuff[y][x] = pfbuff[y][x] ^ fbuff[y][x];
    }
  }
  /*Send only the changed pixels to the screen*/
  for(int y = 0; y < 6; y++)
  {
    for(int x = 0; x < 84; x++)
    {
      //If the current byte is not 0, a pixel has changed
      if(pfbuff[y][x])
      {
        //update the y address in the screen
        int sendy = y | 0b01000000;
        send_byte(sendy, COMM);
        //update the x address in the screen
        int sendx = x | 0b10000000;
        send_byte(sendx, COMM);
        //Send the actual data from the current frame buffer
        send_byte(fbuff[y][x], DATA);
      }
    }
  }

  //Copy the current frame to pfbuff for future comparisons
  for(int y = 0; y < 6; y++)
  {
    for(int x = 0; x < 84; x++)
    {
      pfbuff[y][x] = fbuff[y][x];
    }
  }
}

int main(void)
{
  //Give the AVR a bit to boot
  _delay_ms(200);
  //Initialize the SPI bus
  spi_init_master();
  //Initialize the screen
  screen_init();
  //Blank out the screen
  blank_fbuff();
  //Update the frame
  while(1)
  {
    for(int x = 0; x < 83; x++)
    {
      for(int y = 0; y < 48; y++)
      {
        set_pixel(x, y, BLACK);
        update_frame();
      }
    }
  }
  return(0);
}
