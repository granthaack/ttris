#define F_CPU  16000000UL

#include <avr/io.h>
#include <util/delay.h>
#include <avr/interrupt.h>

typedef unsigned char byte;

#define HIGH 1
#define LOW 0

#define BLACK 1
#define WHITE 0

#define DATA 1
#define COMM 0

//Define the SPI Pins to communicate with the screen
//Define the data direction registers
#define DDR_SPI         DDRB
#define DD_SCK          DDB5
#define DD_MISO         DDB4
#define DD_MOSI         DDB3
#define DD_SS           DDB2
#define DD_DC           DDB1
#define DD_RST          DDB0

//Define the port registers
#define PORT_SPI        PORTB
#define PORT_SCK        (1 << PB5) //yellow
#define PORT_MISO       (1 << PB4) //green (unused)
#define PORT_MOSI       (1 << PB3) //white
#define PORT_SS         (1 << PB2) //orange
#define PORT_DC         (1 << PB1) //blue
#define PORT_RST        (1 << PB0) //green

struct sprite
{
  //The x and y coordinates of where the sprite appears on the spritemap
  int x_map;
  int y_map;
  //The x and y coordinates of where the sprite will be drawn on the screen
  int x_pos;
  int y_pos;
  //The width and height of the sprite
  int wdth;
  int hght;
};

//Init the video buffer
byte fbuff[6][84] = {
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

byte spritemap[2][84] = {0x00, 0x6e, 0x8a, 0xea, 0x8a, 0xee, 0x00, 0x64, 0x84, 0xe4, 0x84, 0x84, 0x00, 0x6e, 0x82, 0xee, 0xa8, 0xee, 0x00, 0xae, 0xa2, 0xee, 0xa2, 0xae, 0x00, 0xea, 0x4a, 0x4e, 0x42, 0xe2, 0x00, 0x2e, 0x28, 0x2e, 0xa2, 0x6e, 0x00, 0xae, 0xa8, 0xce, 0xaa, 0xae, 0x00, 0x8e, 0x82, 0x82, 0x82, 0xe2, 0x00, 0xae, 0xea, 0xee, 0xaa, 0xae, 0x00, 0xae, 0xea, 0xee, 0xe2, 0xae, 0x00, 0x44, 0xaa, 0xae, 0xaa, 0x4a, 0x00, 0xcc, 0xaa, 0xec, 0x8a, 0x8e, 0x00, 0x46, 0xa8, 0xa8, 0xe8, 0x6e, 0x00, 0xcc, 0xaa, 0xea, 0xca, 0xae, 0x00, 0x46, 0x48, 0x44, 0x02, 0x4e, 0x00, 0xee, 0x24, 0x64, 0x04, 0x44, 0x00, 0xaa, 0xaa, 0x0a, 0xaa, 0x46, 0x00, 0xaa, 0x4a, 0xea, 0x44, 0xa4, 0x00, 0x0a, 0x0a, 0x0e, 0x0e, 0x4a, 0x00, 0x4a, 0x4a, 0x04, 0x0a, 0x0a, 0x00, 0xea, 0xea, 0xe4, 0xe4, 0xe4, 0x00, 0x0e, 0x02, 0x04, 0x08, 0x0e, 0x00, 0x06, 0x06, 0x1e, 0x1e, 0x18, 0x18, 0x00, 0x18, 0x18, 0x1e, 0x1e, 0x06, 0x06, 0xc0, 0xc6, 0xf6, 0xf6, 0xc6, 0xc6, 0x06, 0xc6, 0xc6, 0xc0, 0xc6, 0xf6, 0xf6, 0x06, 0x1e, 0x1e, 0x00, 0x1e, 0x1e, 0x1e, 0x1e, 0x00, };

// Initialize SPI Master Device (with SPI interrupt)
void spi_init_master (void)
{
    // Set MOSI, SCK, SS, DC, and RST as Output
    DDR_SPI=(1<<DD_MOSI)|(1<<DD_SCK)|(1<<DD_SS)|(1<<DD_DC)|(1<<DD_RST);

    // Enable SPI, Set as Master
    // Prescaler: Fosc/16, Enable Interrupts
    //The MOSI, SCK pins are as per ATMega8
    SPCR=(1<<SPE)|(1<<MSTR)|(1<<SPR0);
}

//Function to send and receive data for both master and slave
void send_byte(byte data, bool dc)
{
    // Load data into the buffer
    SPDR = data;

    //If DC is high, pull the pin high
    if(dc)
    {
      PORT_SPI |= (PORT_DC);
    }

    //Wait until transmission complete
    while(!(SPSR & (1<<SPIF)));

    //Pull DC low again if it was set high
    if(dc)
    {
      PORT_SPI &= ~(PORT_DC);
    }
    return;
}

void init_screen(void)
{
  //Toggle the reset pin then set it high
  PORT_SPI |= (PORT_RST);
  PORT_SPI &= ~(PORT_RST);
  PORT_SPI |= (PORT_RST);

  //send a byte to init function set
  send_byte(0b00100001, COMM);
  //send byte to init Vop
  send_byte(0b10010000, COMM);
  //send byte to select normal instruction set
  send_byte(0b00100000, COMM);
  //send byte to set screen to normal mode
  send_byte(0b00001100, COMM);
  //set x DDRAM address to 0
  send_byte(0b10000000, COMM);
  //set y DDRAM address to 0
  send_byte(0b01000000, COMM);
}

//This function sets pixels in the display. Instead of changing the frame
//buffer and sending the whole buffer to the screen, this function only changes
//the necessary pixels on the display.
void set_pixel(int x, int y, bool color)
{
  //if out of bounds
  if(x > 83 || y > 47)
  {
    return;
  }

  //Which byte to manipulate
  int i = y/8;
  //Which bit in the byte to manipulate
  int pos = y%8;
  //Positioning the byte for masking or oring
  byte flag = 0x01;
  flag = flag << pos;

  //If setting it black, bitwise or
  if(color)
  {
    //write the changes to the internal fbuff
    fbuff[i][x] = fbuff[i][x] | flag;

    //update the y address
    int sendy = i | 0b01000000;
    send_byte(sendy, COMM);
    //update the x address
    int sendx = x | 0b10000000;
    send_byte(sendx, COMM);

    //Send the updated byte to the screen
    send_byte(fbuff[i][x], DATA);

  }

  //If setting it white, mask and bitwise and
  else
  {
    flag = ~flag;
    fbuff[i][x] = fbuff[i][x] & flag;

    //update the y address
    int sendy = i | 0b01000000;
    send_byte(sendy, COMM);
    //update the x address
    int sendx = x | 0b10000000;
    send_byte(sendx, COMM);

    //Send the updated byte to the screen
    send_byte(fbuff[i][x], DATA);
  }
}

void blank_display()
{
  for(int i = 0; i < 504; i++)
  {
    send_byte(0, DATA);
  }
}

//This function can read pixels in the spritemap or fbuff
bool read_pixel(int x, int y, byte arr[][84])
{
  //Which byte to check
  int i = y/8;
  //Which bit in the byte to check
  int pos = y%8;
  //Positioning the bit for checking
  byte flag = 0x01;
  flag = flag << pos;

  //If there is a bit at that position, this will return true (pixel is black).
  //If there is no bit, this will return false (pixel is white)
  return arr[i][x] & flag;
}

void draw_sprite(sprite* spr)
{
  for(int y = 0; y < spr->hght; y++)
  {
    for(int x = 0; x < spr->wdth; x++)
    {
      if(read_pixel(spr->x_map + x, spr->y_map + y, spritemap))
      {
        set_pixel(spr->x_pos + x, spr->y_pos + y, BLACK);
      }
      else
      {
        set_pixel(spr->x_pos + x, spr->y_pos + y, WHITE);
      }
    }
  }
}

int main(void)
{
  struct sprite zero;
  zero.x_map = 0;
  zero.y_map = 0;
  zero.x_pos = 0;
  zero.y_pos = 0;
  zero.wdth = 6;
  zero.hght = 4;
  //Give the AVR a bit to boot
  _delay_ms(200);
  //Initialize the SPI bus
  spi_init_master();
  //Initialize the screen
  init_screen();
  blank_display();
  //draw a test pattern
  draw_sprite(&zero);
  return(0);
}
