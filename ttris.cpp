#define F_CPU  16000000UL

#include <avr/io.h>
#include <util/delay.h>
#include <avr/interrupt.h>

typedef unsigned char byte;

#define HIGH 1
#define LOW 0

#define BLACK 1
#define WHITE 0

#define DATA 1
#define COMM 0

//Define the SPI Pins to communicate with the screen
//Define the data direction registers
#define DDR_SPI         DDRB
#define DD_SCK          DDB5
#define DD_MISO         DDB4
#define DD_MOSI         DDB3
#define DD_SS           DDB2
#define DD_DC           DDB1
#define DD_RST          DDB0

//Define the port registers
#define PORT_SPI        PORTB
#define PORT_SCK        (1 << PB5) //yellow
#define PORT_MISO       (1 << PB4) //green (unused)
#define PORT_MOSI       (1 << PB3) //white
#define PORT_SS         (1 << PB2) //orange
#define PORT_DC         (1 << PB1) //blue
#define PORT_RST        (1 << PB0) //green

//Init the video buffer
byte vbuff[6][84] = {
  /*
0x4c, 0xaa, 0xec, 0xaa, 0xac, 0x00, 0xaa, 0xee, 0xee, 0xae, 0xaa, 0x00, 0xae, 0xa2, 0x44, 0x48, 0x4e, 0x00, 0x06, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xee, 0xaa, 0xee, 0xa2, 0xee, 0x00, 0xa8, 0xa8, 0xc8, 0xa8, 0xae, 0x00, 0xaa, 0xaa, 0xe4, 0xea, 0xaa, 0x00, 0x82, 0x44, 0x28, 0x44, 0x82, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xee, 0x82, 0xe2, 0xa2, 0xe2, 0x00, 0xe2, 0x42, 0x42, 0x4a, 0xe6, 0x00, 0xaa, 0xaa, 0xaa, 0xa4, 0x64, 0x00, 0x44, 0x4e, 0x44, 0xe4, 0x44, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xae, 0xa8, 0xee, 0x22, 0x2e, 0x00, 0x6a, 0x8a, 0xee, 0xaa, 0xea, 0x00, 0x6e, 0x84, 0x44, 0x24, 0xe4, 0x00, 0x04, 0x04, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xee, 0x22, 0xee, 0x82, 0xee, 0x00, 0xee, 0x88, 0xec, 0x88, 0xe8, 0x00, 0x4c, 0xaa, 0xae, 0xec, 0x6a, 0x00, 0xaa, 0xa4, 0x0e, 0xa4, 0x4a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe4, 0xa4, 0xa4, 0xa4, 0xe4, 0x00, 0x6c, 0x8a, 0x8a, 0x8a, 0xee, 0x00, 0x4c, 0xaa, 0xae, 0xa8, 0x48, 0x00, 0x4e, 0x42, 0x46, 0x00, 0x44, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
*/
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

// Initialize SPI Master Device (with SPI interrupt)
void spi_init_master (void)
{
    // Set MOSI, SCK, SS, DC, and RST as Output
    DDR_SPI=(1<<DD_MOSI)|(1<<DD_SCK)|(1<<DD_SS)|(1<<DD_DC)|(1<<DD_RST);

    // Enable SPI, Set as Master
    // Prescaler: Fosc/16, Enable Interrupts
    //The MOSI, SCK pins are as per ATMega8
    SPCR=(1<<SPE)|(1<<MSTR)|(1<<SPR0);
}

//Function to send and receive data for both master and slave
void send_byte(byte data, bool dc)
{
    // Load data into the buffer
    SPDR = data;

    //If DC is high, pull the pin high
    if(dc)
    {
      PORT_SPI |= (PORT_DC);
    }

    //Wait until transmission complete
    while(!(SPSR & (1<<SPIF)));

    //Pull DC low again if it was set high
    if(dc)
    {
      PORT_SPI &= ~(PORT_DC);
    }
    return;
}

void init_screen(void)
{
  //Toggle the reset pin then set it high
  PORT_SPI |= (PORT_RST);
  PORT_SPI &= ~(PORT_RST);
  PORT_SPI |= (PORT_RST);

  //send a byte to init function set
  send_byte(0b00100001, COMM);
  //send byte to init Vop
  send_byte(0b10010000, COMM);
  //send byte to select normal instruction set
  send_byte(0b00100000, COMM);
  //send byte to set screen to normal mode
  send_byte(0b00001100, COMM);
  //set x DDRAM address to 0
  send_byte(0b10000000, COMM);
  //set y DDRAM address to 0
  send_byte(0b01000000, COMM);
}

//Explanation on this function and why it seems so complex:
//Common sense would dictate that the way updating the display would work is
//the programmer would change a value in the internal vbuff, and then the entire
//vbuff would be sent to to the screen as a single frame. However, this means
//that each time you render a frame, 504 bytes are sent over the wire, no matter
//how small the change to the fram was. If you only changed 1 byte, this is a
//huge waste of bandwidth.
//
//The way this function works is it only updates the pixels that actually
//change. It sets the x and y location of the DDRAM in the display and then
//writes the appropriate data to that single byte only. This is done in 3 bytes
//instead of 504.
//
// vbuff must still be maintained in memory however since the display
//can't send data back, and you can only update one byte at a time. If you
//update a single bit, all the other bits in that byte would get overwritten on
//the screen.

void set_pixel(int x, int y, bool color)
{
  //if out of bounds
  if(x > 83 || y > 47)
  {
    return;
  }

  //Which byte to manipulate
  int i = y/8;
  //Which bit in the byte to manipulate
  int pos = y%8;
  //Positioning the byte for masking or oring
  byte flag = 0x01;
  flag = flag << pos;

  //If setting it black, bitwise or
  if(color)
  {
    //write the changes to the internal vbuff
    vbuff[i][x] = vbuff[i][x] | flag;

    //update the y address
    int sendy = i | 0b01000000;
    send_byte(sendy, COMM);
    //update the x address
    int sendx = x | 0b10000000;
    send_byte(sendx, COMM);

    //Send the updated byte to the screen
    send_byte(vbuff[i][x], DATA);

  }

  //If setting it white, mask and bitwise and
  else
  {
    flag = ~flag;
    vbuff[i][x] = vbuff[i][x] & flag;

    //update the y address
    int sendy = i | 0b01000000;
    send_byte(sendy, COMM);
    //update the x address
    int sendx = x | 0b10000000;
    send_byte(sendx, COMM);

    //Send the updated byte to the screen
    send_byte(vbuff[i][x], DATA);
  }
}

void blank_display(){
  for(int i = 0; i < 504; i++)
  {
    send_byte(0, DATA);
  }
}

int main(void)
{
  //Give the AVR a bit to boot
  _delay_ms(200);
  //Initialize the SPI bus
  spi_init_master();
  //Initialize the screen
  init_screen();
  blank_display();
  //draw a test pattern
  for(int y = 0; y < 48; y++)
  {
    for(int x = 0; x < 84; x++)
    {
      set_pixel(x, y, BLACK);
    }
  }
  return(0);
}
